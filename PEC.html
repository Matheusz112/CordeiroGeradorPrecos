<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCR Cordeiro</title>
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.7.7/dist/axios.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.25.6/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.3/dist/tesseract.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            background: linear-gradient(135deg, #1e40af, #60a5fa);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
        }
        .bubble {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            animation: float 10s infinite;
            pointer-events: none;
        }
        .bubble:nth-child(1) { width: 60px; height: 60px; top: 15%; left: 25%; animation-duration: 8s; }
        .bubble:nth-child(2) { width: 40px; height: 40px; top: 45%; left: 65%; animation-duration: 12s; }
        .bubble:nth-child(3) { width: 50px; height: 50px; top: 55%; left: 35%; animation-duration: 10s; }
        @keyframes float {
            0% { transform: translateY(0); opacity: 0.5; }
            50% { transform: translateY(-60px); opacity: 0.7; }
            100% { transform: translateY(0); opacity: 0.5; }
        }
        .image-container {
            height: 160px;
            overflow: hidden;
            position: relative;
            border-radius: 10px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            background: #fff;
        }
        .image-container img {
            width: 100%;
            height: auto;
            object-fit: contain;
            object-position: center;
        }
        .scanning-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, transparent, #60a5fa, transparent);
            animation: scanWave 1.2s infinite ease-in-out;
        }
        @keyframes scanWave {
            0% { transform: translateY(0); opacity: 0.5; }
            50% { transform: translateY(160px); opacity: 0.9; }
            100% { transform: translateY(0); opacity: 0.5; }
        }
        .icon {
            width: 20px;
            height: 20px;
            vertical-align: middle;
        }
        .neon-button {
            background: #2563eb;
            box-shadow: 0 0 8px #2563eb, 0 0 16px rgba(37, 99, 235, 0.5);
            transition: all 0.3s ease;
            border-radius: 8px;
            padding: 12px 24px;
            font-weight: 700;
            animation: pulse 2s infinite ease-in-out;
        }
        .neon-button:hover:not(:disabled) {
            box-shadow: 0 0 16px #2563eb, 0 0 24px rgba(37, 99, 235, 0.7);
            transform: scale(1.05);
        }
        .neon-button:disabled {
            background: #6b7280;
            box-shadow: none;
            cursor: not-allowed;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 8px #2563eb, 0 0 16px rgba(37, 99, 235, 0.5); }
            50% { box-shadow: 0 0 12px #2563eb, 0 0 20px rgba(37, 99, 235, 0.7); }
            100% { box-shadow: 0 0 8px #2563eb, 0 0 16px rgba(37, 99, 235, 0.5); }
        }
        .success-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(34, 197, 94, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            animation: popIn 0.5s ease-out, fadeOut 0.5s ease-out 1.5s forwards;
            z-index: 1000;
        }
        .checkmark {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            stroke-width: 2;
            stroke: #fff;
            stroke-miterlimit: 10;
            animation: fill 0.4s ease-in-out 0.4s forwards, scale 0.3s ease-in-out 0.9s both;
        }
        .checkmark__circle {
            stroke-dasharray: 166;
            stroke-dashoffset: 166;
            stroke-width: 2;
            stroke: #22c55e;
            fill: none;
            animation: stroke 0.6s cubic-bezier(0.65, 0, 0.45, 1) forwards;
        }
        .checkmark__check {
            transform-origin: 50% 50%;
            stroke-dasharray: 48;
            stroke-dashoffset: 48;
            animation: stroke 0.3s cubic-bezier(0.65, 0, 0.45, 1) 0.8s forwards;
        }
        @keyframes stroke {
            100% { stroke-dashoffset: 0; }
        }
        @keyframes scale {
            0%, 100% { transform: none; }
            50% { transform: scale3d(1.2, 1.2, 1); }
        }
        @keyframes fill {
            100% { box-shadow: inset 0px 0px 0px 40px #22c55e; }
        }
        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        .progress-bar {
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: #2563eb;
            transition: width 0.3s ease;
        }
        .confidence-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }
        .confidence-fill {
            height: 100%;
            background: linear-gradient(to right, #ef4444, #eab308, #22c55e);
            transition: width 0.4s ease;
        }
        .confidence-label {
            font-size: 0.75rem;
            color: #e5e7eb;
            text-align: center;
            margin-top: 6px;
        }
        .warning-modal {
            animation: popIn 0.5s ease-out;
            background: rgba(239, 68, 68, 0.9);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        .text-bbox-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        main {
            background: rgba(31, 41, 55, 0.9);
            border-radius: 10px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }
        select, input {
            background: #374151;
            border: 1px solid #4b5563;
            border-radius: 6px;
            transition: border-color 0.3s ease;
        }
        select:focus, input:focus {
            outline: none;
            border-color: #60a5fa;
            box-shadow: 0 0 8px rgba(96, 165, 250, 0.3);
        }
    </style>
</head>
<body>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div id="root"></div>
    <script>
        window.addEventListener('error', (event) => {
            console.error('Erro global:', event.message, event.filename, event.lineno, event.colno, event.error?.stack || 'No stack trace');
            document.getElementById('root').innerHTML = `
                <div class="bg-red-900/50 text-red-300 p-4 rounded text-center">
                    Erro cr√≠tico: ${event.message}. Verifique o console.
                </div>
            `;
        });

        function preprocessImage(base64Image, callback) {
            const img = new Image();
            img.src = `data:image/jpeg;base64,${base64Image}`;
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                // Grayscale and adaptive thresholding
                for (let i = 0; i < data.length; i += 4) {
                    const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = data[i + 1] = data[i + 2] = avg > 128 ? 255 : 0;
                }

                // Increase contrast
                const contrast = 1.5;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, Math.max(0, (data[i] - 128) * contrast + 128));
                    data[i + 1] = Math.min(255, Math.max(0, (data[i + 1] - 128) * contrast + 128));
                    data[i + 2] = Math.min(255, Math.max(0, (data[i + 2] - 128) * contrast + 128));
                }

                ctx.putImageData(imageData, 0, 0);
                callback(canvas.toDataURL('image/jpeg').split(',')[1]);
            };
            img.onerror = () => callback(null);
        }

        function drawTextBoundingBoxes(imageElement, words) {
            // Remove existing canvas if present
            const existingCanvas = imageElement.parentElement.querySelector('.text-bbox-canvas');
            if (existingCanvas) existingCanvas.remove();

            const canvas = document.createElement('canvas');
            canvas.className = 'text-bbox-canvas';
            const ctx = canvas.getContext('2d');
            const container = imageElement.parentElement;

            // Match canvas to image's displayed size
            const rect = imageElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;

            // Scale bounding boxes to match displayed image
            const scaleX = rect.width / imageElement.naturalWidth;
            const scaleY = rect.height / imageElement.naturalHeight;

            container.style.position = 'relative';
            container.appendChild(canvas);

            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            words.forEach(word => {
                if (word.bbox && word.confidence >= 50) {
                    const { x0, y0, x1, y1 } = word.bbox;
                    ctx.beginPath();
                    ctx.rect(x0 * scaleX, y0 * scaleY, (x1 - x0) * scaleX, (y1 - y0) * scaleY);
                    ctx.stroke();
                    // Highlight volume-related words in blue
                    if (word.text.match(/(\d+)(ML|L|LT|LTR|LTRO|LITRO)/i) || knownVolumes.includes(parseInt(word.text))) {
                        ctx.strokeStyle = 'blue';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.rect(x0 * scaleX, y0 * scaleY, (x1 - x0) * scaleX, (y1 - y0) * scaleY);
                        ctx.stroke();
                        ctx.strokeStyle = 'red';
                        ctx.lineWidth = 2;
                    }
                }
            });
        }
    </script>
    <script type="text/babel">
        const bancoDeDados = [
            { id: 3, PRODUTO: 'CERV LAGER HEINEKEN LN 6X330ml', ML: 330, brand: 'HEINEKEN' },
            { id: 4, PRODUTO: 'CERV STELLA ARTOIS LN 6X330ml', ML: 330, brand: 'STELLA ARTOIS' },
            { id: 5, PRODUTO: 'CERV LAGER CORONA LN 6X330ml', ML: 330, brand: 'CORONA' },
            { id: 6, PRODUTO: 'CERV LAGER BUDWEISER LN 6X330ml', ML: 330, brand: 'BUDWEISER' },
            { id: 7, PRODUTO: 'CERV HEINEKEN ZERO ALC LN 6X330ml', ML: 330, brand: 'HEINEKEN' },
            { id: 8, PRODUTO: 'CERV P MALTE SPATEM LN 6X355ml', ML: 355, brand: 'SPATEM' },
            { id: 9, PRODUTO: 'CERV BRAHMA ZERO √ÅLCOOL 12X350ml', ML: 350, brand: 'BRAHMA' },
            { id: 10, PRODUTO: 'CERV HEINEKEN ZERO √ÅLCOOL 12X350ml', ML: 350, brand: 'HEINEKEN' },
            { id: 11, PRODUTO: 'CERV EISENBAHN 12X473ml', ML: 473, brand: 'EISENBAHN' },
            { id: 12, PRODUTO: 'CERVEJA LAGER AMSTEL 12X473ml', ML: 473, brand: 'AMSTEL' },
            { id: 13, PRODUTO: 'CERV HEINEKEN LT 12X473ml', ML: 473, brand: 'HEINEKEN' },
            { id: 14, PRODUTO: 'CERVEJA KAISER 12X473ml', ML: 473, brand: 'KAISER' },
            { id: 15, PRODUTO: 'CERV PILSEN ANTARTICA 12X473ml', ML: 473, brand: 'ANTARTICA' },
            { id: 16, PRODUTO: 'CERV ANTARCTICA ORIGINAL 12X473ml', ML: 473, brand: 'ANTARTICA' },
            { id: 17, PRODUTO: 'CERVEJA BRAHMA 12X473ml', ML: 473, brand: 'BRAHMA' },
            { id: 18, PRODUTO: 'CERVEJA STELLA ARTOIS 12X473ml', ML: 473, brand: 'STELLA ARTOIS' },
            { id: 19, PRODUTO: 'CERVEJA P MALTE BOHEMIA 473ml', ML: 473, brand: 'BOHEMIA' },
            { id: 20, PRODUTO: 'CERV P MALTE SPATEM LT 12X473ml', ML: 473, brand: 'SPATEM' },
            { id: 21, PRODUTO: 'CERV ANTARCTICA SUB ZERO 473ml', ML: 473, brand: 'ANTARTICA' },
            { id: 22, PRODUTO: 'LEITE ITAMB√ä INTEGRAL 12X1L', ML: 1, brand: 'ITAMB√ä' },
            { id: 23, PRODUTO: 'LEITE ITAMB√ä DESNATADO 12X1L', ML: 1, brand: 'ITAMB√ä' },
            { id: 24, PRODUTO: 'LEITE ITAMB√ä SEMIDESNATADO 12X1L', ML: 1, brand: 'ITAMB√ä' },
            { id: 25, PRODUTO: 'LEITE PORTO ALEGRE INTEGRAL 12X1L', ML: 1, brand: 'PORTO ALEGRE' },
            { id: 26, PRODUTO: 'LEITE QUATA INTEGRAL 12X1L', ML: 1, brand: 'QUATA' },
            { id: 27, PRODUTO: 'LEITE PIRACANJUBA INTEGRAL 12X1L', ML: 1, brand: 'PIRACANJUBA' },
            { id: 28, PRODUTO: '√ÅGUA IGARAPE SEM G√ÅS 12X500ml', ML: 500, brand: 'IGARAPE' },
            { id: 29, PRODUTO: '√ÅGUA IGARAP√â COM G√ÅS 12X500ml', ML: 500, brand: 'IGARAPE' },
            { id: 30, PRODUTO: 'REFRI COCA COLA MINI PET 12X200ml', ML: 200, brand: 'COCA COLA' },
            { id: 31, PRODUTO: 'REFRI SUKITA LARANJA PET 12X200ml', ML: 200, brand: 'SUKITA' },
            { id: 32, PRODUTO: 'REFRI SODA LIMONADA PET 12X200ml', ML: 200, brand: 'SODA' },
            { id: 33, PRODUTO: 'REFRI GUARAN√Å ANTARTICA PET 12X200ml', ML: 200, brand: 'GUARAN√Å ANTARTICA' },
            { id: 34, PRODUTO: 'REFRI GUARAN√Å ZERO PET 12X200ml', ML: 200, brand: 'GUARAN√Å ANTARTICA' },
            { id: 35, PRODUTO: 'REFRI PEPSI PET 12X200ml', ML: 200, brand: 'PEPSI' },
            { id: 36, PRODUTO: '√ìLEO DE SOJA VELEIRO 6X900ml', ML: 900, brand: 'VELEIRO' },
            { id: 37, PRODUTO: '√ìLEO DE SOJA LIZA 6X900ml', ML: 900, brand: 'LIZA' },
            { id: 38, PRODUTO: 'CERV MALZBIER BRAHMA 6X355ml', ML: 355, brand: 'BRAHMA' },
            { id: 39, PRODUTO: 'CERV PILSEN IMPERIO 12X473ml', ML: 473, brand: 'IMPERIO' },
            { id: 40, PRODUTO: 'CERV PILSEN BUDWEISER 12X473ml', ML: 473, brand: 'BUDWEISER' },
            { id: 67, PRODUTO: 'LEITE INTEGRAL ITA 12X1L', ML: 1, brand: 'ITA' },
            { id: 68, PRODUTO: 'LEITE INTEGRAL ITALAC 12X1L', ML: 1, brand: 'ITALAC' },
            { id: 69, PRODUTO: 'AGUA MIN GRAO MOGOL 12X500ml', ML: 500, brand: 'GRAO MOGOL' },
            { id: 70, PRODUTO: 'CERV P MALTE SPATEM LN 6X355ml', ML: 355, brand: 'SPATEM' },
            { id: 71, PRODUTO: 'CERV LAGER HEINEKEN LN 6X355ml', ML: 330, brand: 'HEINEKEN' },
            { id: 72, PRODUTO: 'CERV PILSEN BRUDER BX GASTRO 12X473ml', ML: 473, brand: 'BRUDER' },
            { id: 73, PRODUTO: 'CERV PILSEN LAUT 12X473ml', ML: 473, brand: 'LAUT' },
            { id: 74, PRODUTO: 'CERV P MALTE PETRA 12X473ml', ML: 473, brand: 'PETRA' },
            { id: 75, PRODUTO: 'CERV PILSEN ITAIPAVA LT 12X473ml', ML: 473, brand: 'ITAIPAVA' },
            { id: 76, PRODUTO: 'CERV PILSEN SKOL LT 12X473ml', ML: 473, brand: 'SKOL' },
            { id: 100, PRODUTO: 'CERV LAGER CORONA LN 6X330ml', ML: 330, brand: 'CORONA' },
            { id: 133, PRODUTO: 'CERV LAGER BUDWEISER LN 6X330ml', ML: 330, brand: 'BUDWEISER' },
            { id: 167, PRODUTO: 'CERV PILSEN LAUT 12X473ml', ML: 473, brand: 'LAUT' },
            { id: 199, PRODUTO: 'REFRI CA√áULINHA SODA 12X200ml', ML: 200, brand: 'CA√áULINHA' },
            { id: 232, PRODUTO: 'CERV LAGER HEINEKEN LN 6X330ml', ML: 330, brand: 'HEINEKEN' },
            { id: 233, PRODUTO: 'CERV LAGER HEINEKEN LN 6X330ml', ML: 330, brand: 'HEINEKEN' },
            { id: 265, PRODUTO: 'CERVEJA KAISER 12X473ml', ML: 473, brand: 'KAISER' },
            { id: 266, PRODUTO: 'CERV MALZIBIER CARACU 12X350ml', ML: 350, brand: 'CARACU' },
            { id: 298, PRODUTO: 'LEITE INTEGRAL CEMIL 12X1L', ML: 1, brand: 'CEMIL' },
            { id: 331, PRODUTO: 'CERV ZERO ALC BUDWEISER LN 6x330ml', ML: 330, brand: 'BUDWEISER' },
            { id: 364, PRODUTO: 'CERV AMERICA IPA EISENBAHN LN 6X355ml', ML: 355, brand: 'EISENBAHN' },
            { id: 65, PRODUTO: 'CERV PALE ALE EISENBAHN LN 6X355ml', ML: 355, brand: 'EISENBAHN' },
            { id: 366, PRODUTO: 'CERV PILSEN BRAHMA LN 6X355ml', ML: 355, brand: 'BRAHMA' },
            { id: 367, PRODUTO: 'CERV UTRA AMSTEL LN 6X275ml', ML: 275, brand: 'AMSTEL' },
            { id: 368, PRODUTO: 'FANTA LARANJA ZERO 12x2l', ML: 2, brand: 'FANTA' },
            { id: 397, PRODUTO: 'COQ COROTE LIM√ÉO 12X500ml', ML: 500, brand: 'COROTE' }
        ];

        const keywords = [
            'CERV', 'CERVEJA', 'LAGER', 'PILSEN', 'ZERO', 'ALC', 'MALTE', 'ORIGINAL', 'SUB',
            'LEITE', 'INTEGRAL', 'DESNATADO', 'SEMIDESNATADO', 'AGUA', 'GAS', 'REFRI', 'SODA',
            'LIMONADA', 'GUARANA', 'OLEO', 'SOJA', 'MALZBIER', 'IPA', 'PALE', 'ALE', 'UTRA'
        ];

        const brandPrefixes = [
            { prefix: 'HEI', brand: 'HEINEKEN', score: 60 },
            { prefix: 'STE', brand: 'STELLA ARTOIS', score: 60 },
            { prefix: 'COR', brand: 'CORONA', score: 60 },
            { prefix: 'BUD', brand: 'BUDWEISER', score: 60 },
            { prefix: 'SPA', brand: 'SPATEM', score: 60 },
            { prefix: 'BRA', brand: 'BRAHMA', score: 60 },
            { prefix: 'EIS', brand: 'EISENBAHN', score: 60 },
            { prefix: 'AMS', brand: 'AMSTEL', score: 60 },
            { prefix: 'KAI', brand: 'KAISER', score: 60 },
            { prefix: 'ANT', brand: 'ANTARTICA', score: 60 },
            { prefix: 'BOH', brand: 'BOHEMIA', score: 60 },
            { prefix: 'ITA', brand: 'ITAIPAVA', score: 60 },
            { prefix: 'SKO', brand: 'SKOL', score: 60 },
            { prefix: 'PET', brand: 'PETRA', score: 60 },
            { prefix: 'LAU', brand: 'LAUT', score: 60 },
            { prefix: 'BRU', brand: 'BRUDER', score: 60 },
            { prefix: 'ITAM', brand: 'ITAMB√ä', score: 60 },
            { prefix: 'PORTO', brand: 'PORTO ALEGRE', score: 60 },
            { prefix: 'QUA', brand: 'QUATA', score: 60 },
            { prefix: 'PIR', brand: 'PIRACANJUBA', score: 60 },
            { prefix: 'IGA', brand: 'IGARAPE', score: 60 },
            { prefix: 'COC', brand: 'COCA COLA', score: 60 },
            { prefix: 'SUK', brand: 'SUKITA', score: 60 },
            { prefix: 'GUA', brand: 'GUARAN√Å ANTARTICA', score: 60 },
            { prefix: 'PEP', brand: 'PEPSI', score: 60 },
            { prefix: 'VELE', brand: 'VELEIRO', score: 60 },
            { prefix: 'LIZ', brand: 'LIZA', score: 60 },
            { prefix: 'CAR', brand: 'CARACU', score: 60 },
            { prefix: 'CEM', brand: 'CEMIL', score: 60 },
            { prefix: 'FAN', brand: 'FANTA', score: 60 },
            { prefix: 'COQ', brand: 'COROTE', score: 60 }
        ];

        const knownVolumes = [473, 330, 350, 500, 200, 900, 1, 355, 275, 2];

        function formatVolume(ml) {
            if (ml <= 2) {
                return `${ml}L`;
            }
            return `${ml}ml`;
        }

        function calculatePriceConfidence(price, rawText) {
            let score = 0;
            if (/R\$\s*\d+[,.]\d{2}/.test(rawText)) score += 50;
            else if (/\d+[,.]\d{2}/.test(price)) score += 30;
            else if (/\d+[,.]\d/.test(price)) score += 20;
            else if (/^\d+$/.test(price) && !knownVolumes.includes(parseInt(price))) score += 10;
            if (/(PRE√áO|VALOR|R\$)/i.test(rawText)) score += 15;
            const confidence = Math.min(100, score);
            return {
                confidence,
                emoji: confidence >= 80 ? 'üòé' : confidence >= 50 ? 'üòä' : confidence >= 20 ? 'üòê' : 'üòû',
                label: confidence >= 80 ? 'Muito Bom' : confidence >= 50 ? 'Bom' : confidence >= 20 ? 'M√©dio' : 'Ruim'
            };
        }

        function validatePrice(price, isCervProduct, rawText) {
            if (!price || /R\$\s*0,00/i.test(rawText)) {
                return { price: '0,00', confidence: 0, emoji: 'üòû', label: 'Ruim' };
            }

            let numPrice;
            const volumeLike = ['473', '330', '350', '500', '200', '900', '1', '355', '275', '2'];
            price = price.replace(',', '.').replace(/[^\d.]/g, '');
            if (/^\d+$/.test(price) && volumeLike.includes(price)) {
                price = '0,00';
            } else if (/^\d+[,.]\d{2}$/.test(price)) {
                price = price.replace('.', ',');
            } else if (/^\d+[,.]\d$/.test(price)) {
                price = `${price[0]},${price.slice(2) || '0'}0`;
            } else if (/^\d+$/.test(price)) {
                price = `${price},00`;
            } else {
                price = '0,00';
            }
            numPrice = parseFloat(price.replace(',', '.'));
            if (isNaN(numPrice)) {
                return { price: '0,00', confidence: 0, emoji: 'üòû', label: 'Ruim' };
            }
            if (isCervProduct && numPrice < 0.20) {
                return { price: '0,00', confidence: 0, emoji: 'üòû', label: 'Ruim' };
            }
            if (numPrice > 12.00) {
                numPrice = 12.00;
            }
            const finalPrice = numPrice.toFixed(2).replace('.', ',');
            const { confidence, emoji, label } = calculatePriceConfidence(finalPrice, rawText);
            return { price: finalPrice, confidence, emoji, label };
        }

        function correctOcrText(text) {
            if (typeof text !== 'string') {
                console.warn('correctOcrText: Input n√£o √© uma string, retornando vazio', text);
                return '';
            }
            const corrections = [
                { wrong: /\b[Ss](?=\d*[,.]\d)/gi, correct: '5' }, // S/s before decimal in prices
                { wrong: /\b[Oo](?=\d*[,.]\d)/gi, correct: '0' }, // O/o before decimal in prices
                { wrong: /\b(RS|RZ|S)\b/gi, correct: 'R$' },
                { wrong: /\b(\d+)[,.](\d{1,2})\b/gi, correct: '$1,$2' },
                { wrong: /\bHE1NEKEN\b/gi, correct: 'HEINEKEN' },
                { wrong: /\bSTEL1A\b/gi, correct: 'STELLA' },
                { wrong: /\bC0R0NA\b/gi, correct: 'CORONA' },
                { wrong: /\bBUDWE1SER\b/gi, correct: 'BUDWEISER' },
                { wrong: /\bSPATEN\b/gi, correct: 'SPATEM' },
                { wrong: /\bBRAMA\b/gi, correct: 'BRAHMA' },
                { wrong: /\bE1SENBAHN\b/gi, correct: 'EISENBAHN' },
                { wrong: /\bAMST3L\b/gi, correct: 'AMSTEL' },
                { wrong: /\bKA1SER\b/gi, correct: 'KAISER' },
                { wrong: /\bANTART1CA\b/gi, correct: 'ANTARTICA' },
                { wrong: /\bB0HEMIA\b/gi, correct: 'BOHEMIA' },
                { wrong: /\bSK0L\b/gi, correct: 'SKOL' },
                { wrong: /\b1TA1PAVA\b/gi, correct: 'ITAIPAVA' },
                { wrong: /\b(LT|LTR|LTRO)\b/gi, correct: 'LITRO' } // Correct LT/LTR to LITRO
            ];
            let corrected = text;
            corrections.forEach(({ wrong, correct }) => {
                corrected = corrected.replace(wrong, correct);
            });
            return corrected;
        }

        function normalizeText(text) {
            if (typeof text !== 'string') {
                console.warn('normalizeText: Input n√£o √© uma string, retornando vazio', text);
                return '';
            }
            return text
                .toUpperCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                .replace(/\s+/g, ' ')
                .replace(/[^A-Z0-9\s]/g, '')
                .trim();
        }

        function findBestMatch(normalizedText, database) {
            let bestMatch = database[0];
            let highestScore = -Infinity;
            const volumeMatch = normalizedText.match(/(\d+)(ML|L|LT|LTR|LTRO|LITRO)/i);
            const volume = volumeMatch ? parseInt(volumeMatch[1]) : null;
            const isLiter = volumeMatch && /L|LT|LTR|LTRO|LITRO/i.test(volumeMatch[2]);

            database.forEach(product => {
                const normalizedProduct = normalizeText(product.PRODUTO);
                const productWords = normalizedProduct.split(' ');
                const textWords = normalizedText.split(' ');
                let score = 0;

                // Brand matching
                const productBrand = normalizeText(product.brand);
                if (normalizedText.includes(productBrand)) {
                    score += 100; // High weight for exact brand match
                } else {
                    brandPrefixes.forEach(({ prefix, brand, score: prefixScore }) => {
                        if (normalizedText.includes(prefix) && productBrand.includes(brand)) {
                            score += prefixScore;
                        }
                    });
                }

                // Keyword matching
                productWords.forEach(word => {
                    if (textWords.includes(word)) {
                        score += keywords.includes(word) ? 20 : 5;
                    }
                });

                // Volume matching
                if (volume) {
                    if (isLiter && product.ML <= 2 && volume === product.ML) {
                        score += 70; // Higher weight for liter match
                    } else if (!isLiter && product.ML === volume) {
                        score += 50; // Standard weight for ml match
                    }
                    if (knownVolumes.includes(volume)) score += 20;
                }

                // Levenshtein distance
                const distance = Math.min(
                    ...productWords.map(pWord =>
                        Math.min(...textWords.map(tWord => {
                            const matrix = Array(tWord.length + 1).fill().map(() => Array(pWord.length + 1).fill(0));
                            for (let i = 0; i <= pWord.length; i++) matrix[0][i] = i;
                            for (let j = 0; j <= tWord.length; j++) matrix[j][0] = j;
                            for (let j = 1; j <= tWord.length; j++) {
                                for (let i = 1; i <= pWord.length; i++) {
                                    matrix[j][i] = Math.min(
                                        matrix[j][i - 1] + 1,
                                        matrix[j - 1][i] + 1,
                                        matrix[j - 1][i - 1] + (pWord[i - 1] === tWord[j - 1] ? 0 : 1)
                                    );
                                }
                            }
                            return matrix[tWord.length][pWord.length];
                        }))
                    )
                );
                score += (1 - distance / Math.max(normalizedText.length, normalizedProduct.length)) * 30;

                if (score > highestScore) {
                    highestScore = score;
                    bestMatch = product;
                }
            });

            return bestMatch;
        }

        async function retryOperation(fn, maxRetries = 3, delay = 500) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    return await fn();
                } catch (err) {
                    console.error(`Tentativa ${attempt} falhou: ${err.message}`);
                    if (attempt === maxRetries) throw err;
                    await new Promise(resolve => setTimeout(resolve, delay * attempt));
                }
            }
        }

        function ConfidenceBar({ confidence, emoji, label }) {
            return (
                <div>
                    <div className="confidence-bar">
                        <div className="confidence-fill" style={{ width: `${confidence}%` }}></div>
                    </div>
                    <div className="confidence-label">{emoji} {label} ({confidence}%)</div>
                </div>
            );
        }

        function App() {
            const [state, setState] = React.useState({
                imageUrl: '',
                ocrResults: {},
                selectedOcr: 'ocrspace',
                loading: false,
                error: null,
                editPrice: false,
                newPrice: '',
                success: false,
                priceDetected: false,
                progress: 0
            });
            const imageRef = React.useRef(null);

            const updateState = (updates) => setState(prev => ({ ...prev, ...updates }));

            React.useEffect(() => {
                const fetchImage = async () => {
                    updateState({ loading: true });
                    try {
                        const response = await retryOperation(() =>
                            axios.get(
                                "https://api.baserow.io/api/database/rows/table/587819/2/?user_field_names=true",
                                { headers: { Authorization: "Token UkqZsuMMnwE59fMqs8OwXX60SASP7FOd" } }
                            )
                        );
                        updateState({ imageUrl: response.data.urlimagem });
                    } catch (err) {
                        updateState({ error: `Erro ao buscar imagem: ${err.message}` });
                    } finally {
                        updateState({ loading: false });
                    }
                };
                fetchImage();
            }, []);

            React.useEffect(() => {
                if (state.imageUrl) processImage(state.imageUrl);
            }, [state.imageUrl]);

            React.useEffect(() => {
                if (imageRef.current && state.ocrResults[state.selectedOcr]?.result?.words?.length > 0) {
                    drawTextBoundingBoxes(imageRef.current, state.ocrResults[state.selectedOcr].result.words);
                }
            }, [state.selectedOcr, state.ocrResults]);

            const processImage = async (url) => {
                updateState({ loading: true, error: null, progress: 0 });
                try {
                    const response = await retryOperation(() =>
                        axios.get(url, { responseType: 'blob' })
                    );
                    const reader = new FileReader();
                    reader.readAsDataURL(response.data);
                    reader.onloadend = () => {
                        const base64Image = reader.result.split(',')[1];
                        preprocessImage(base64Image, async (processedImage) => {
                            if (!processedImage) {
                                updateState({ error: 'Erro ao preprocessar imagem', loading: false });
                                return;
                            }
                            const results = {};
                            const ocrPromises = [
                                // OCR.Space
                                (async () => {
                                    try {
                                        const formData = new FormData();
                                        formData.append('base64Image', `data:image/jpeg;base64,${processedImage}`);
                                        formData.append('language', 'por');
                                        formData.append('isOverlayRequired', 'true');
                                        formData.append('OCREngine', '2');
                                        const ocrSpaceResponse = await retryOperation(() =>
                                            axios.post('https://api.ocr.space/parse/image', formData, {
                                                headers: { 'apikey': 'K86154304788957', 'Content-Type': 'multipart/form-data' }
                                            })
                                        );
                                        updateState({ progress: 50 });
                                        const ocrText = ocrSpaceResponse.data?.ParsedResults?.[0]?.ParsedText || '';
                                        if (!ocrText && ocrSpaceResponse.data) {
                                            console.warn('OCR.Space retornou resposta inv√°lida:', ocrSpaceResponse.data);
                                        }
                                        const correctedText = correctOcrText(ocrText);
                                        const normalizedText = normalizeText(correctedText);
                                        let ocrPrice = correctedText.match(/(R\$)?\s*\d+[,.]\d{2}/)?.[0] || 
                                                      correctedText.match(/(R\$)?\s*\d+[,.]\d/)?.[0] || '';
                                        ocrPrice = ocrPrice.replace(/R\$/, '').trim();
                                        if (!ocrPrice) ocrPrice = '0,00';
                                        const matchedProduct = findBestMatch(normalizedText, bancoDeDados);
                                        const isCervProduct = normalizedText.includes('CERV') || normalizedText.includes('CERVEJA');
                                        const { price: validatedPrice, confidence, emoji, label } = validatePrice(ocrPrice, isCervProduct, correctedText);
                                        // Extract bounding boxes from OCR.Space response
                                        const words = ocrSpaceResponse.data?.ParsedResults?.[0]?.TextOverlay?.Lines?.flatMap(line =>
                                            line.Words.map(word => ({
                                                text: word.WordText,
                                                confidence: word.Confidence || 50,
                                                bbox: {
                                                    x0: word.Left,
                                                    y0: word.Top,
                                                    x1: word.Left + word.Width,
                                                    y1: word.Top + word.Height
                                                }
                                            }))
                                        ) || [];
                                        return {
                                            source: 'ocrspace',
                                            result: {
                                                product: matchedProduct.PRODUTO,
                                                volume: matchedProduct.ML,
                                                price: `R$ ${validatedPrice}`,
                                                id: matchedProduct.id,
                                                rawText: correctedText,
                                                confidence,
                                                emoji,
                                                label,
                                                words
                                            }
                                        };
                                    } catch (err) {
                                        console.error('Erro no OCR.Space:', err.message, 'Resposta:', err.response?.data);
                                        return {
                                            source: 'ocrspace',
                                            result: {
                                                error: `Erro no OCR.Space: ${err.message}. Verifique a resposta da API no console.`,
                                                rawText: '',
                                                product: bancoDeDados[0].PRODUTO,
                                                volume: bancoDeDados[0].ML,
                                                price: 'R$ 0,00',
                                                id: bancoDeDados[0].id,
                                                confidence: 0,
                                                emoji: 'üòû',
                                                label: 'Ruim',
                                                words: []
                                            }
                                        };
                                    }
                                })(),
                                // Tesseract
                                (async () => {
                                    try {
                                        const { data } = await Tesseract.recognize(
                                            `data:image/jpeg;base64,${processedImage}`,
                                            'por',
                                            { tessedit_pageseg_mode: Tesseract.PSM.SINGLE_BLOCK }
                                        );
                                        updateState({ progress: 100 });
                                        const ocrText = data.text || '';
                                        const correctedText = correctOcrText(ocrText);
                                        const normalizedText = normalizeText(correctedText);
                                        let ocrPrice = correctedText.match(/(R\$)?\s*\d+[,.]\d{2}/)?.[0] || 
                                                      correctedText.match(/(R\$)?\s*\d+[,.]\d/)?.[0] || '';
                                        ocrPrice = ocrPrice.replace(/R\$/, '').trim();
                                        if (!ocrPrice) ocrPrice = '0,00';
                                        const matchedProduct = findBestMatch(normalizedText, bancoDeDados);
                                        const isCervProduct = normalizedText.includes('CERV') || normalizedText.includes('CERVEJA');
                                        const { price: validatedPrice, confidence, emoji, label } = validatePrice(ocrPrice, isCervProduct, correctedText);
                                        const priceStr = `R$ ${validatedPrice}`;
                                        return {
                                            source: 'tesseract',
                                            result: {
                                                rawText: correctedText,
                                                product: matchedProduct.PRODUTO,
                                                volume: matchedProduct.ML,
                                                price: priceStr,
                                                id: matchedProduct.id,
                                                confidence,
                                                emoji,
                                                label,
                                                words: data.words || []
                                            }
                                        };
                                    } catch (err) {
                                        console.error('Erro no Tesseract:', err.message);
                                        return {
                                            source: 'tesseract',
                                            result: {
                                                error: `Erro no Tesseract: ${err.message}`,
                                                rawText: '',
                                                product: bancoDeDados[0].PRODUTO,
                                                volume: bancoDeDados[0].ML,
                                                price: 'R$ 0,00',
                                                id: bancoDeDados[0].id,
                                                confidence: 0,
                                                emoji: 'üòû',
                                                label: 'Ruim',
                                                words: []
                                            }
                                        };
                                    }
                                })()
                            ];

                            const allResults = await Promise.all(ocrPromises);
                            allResults.forEach(res => {
                                if (res && res.source && res.result) results[res.source] = { result: res.result };
                            });

                            const validSource = !results.ocrspace?.result.error ? 'ocrspace' : 'tesseract';
                            updateState({
                                ocrResults: results,
                                selectedOcr: validSource,
                                newPrice: results[validSource]?.result?.price?.replace('R$ ', '') || '0,00',
                                confidenceData: {
                                    confidence: results[validSource]?.result?.confidence || 0,
                                    emoji: results[validSource]?.result?.emoji || 'üòû',
                                    label: results[validSource]?.result?.label || 'Ruim'
                                },
                                loading: false
                            });

                            if (results[validSource]?.result?.price && results[validSource].result.price !== 'R$ 0,00') {
                                updateState({ priceDetected: true });
                                confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 } });
                                setTimeout(() => updateState({ priceDetected: false }), 1500);
                            }
                        });
                    };
                    reader.onerror = () => updateState({ error: 'Erro ao ler imagem', loading: false });
                } catch (err) {
                    updateState({ error: `Erro ao processar imagem: ${err.message}`, loading: false });
                }
            };

            const handlePriceChange = () => {
                if (!state.newPrice || !state.ocrResults[state.selectedOcr]) return;
                const isCervProduct = state.ocrResults[state.selectedOcr].result.product.includes('CERV') || state.ocrResults[state.selectedOcr].result.product.includes('CERVEJA');
                const { price: validatedPrice, confidence, emoji, label } = validatePrice(state.newPrice, isCervProduct, state.ocrResults[state.selectedOcr].result.rawText);
                if (validatedPrice) {
                    updateState({
                        ocrResults: {
                            ...state.ocrResults,
                            [state.selectedOcr]: {
                                ...state.ocrResults[state.selectedOcr],
                                result: { ...state.ocrResults[state.selectedOcr].result, price: `R$ ${validatedPrice}`, confidence, emoji, label }
                            }
                        },
                        confidenceData: { confidence, emoji, label },
                        priceDetected: true,
                        editPrice: false
                    });
                    confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 } });
                    setTimeout(() => updateState({ priceDetected: false }), 1500);
                }
            };

            const handleSubmit = async (result) => {
                if (!result?.id || !result?.price || result.price === 'R$ 0,00') return;
                updateState({ loading: true, error: null });
                try {
                    await retryOperation(() =>
                        axios.patch(
                            `https://api.baserow.io/api/database/rows/table/322640/${result.id}/?user_field_names=true`,
                            { "PRE√áO": result.price.replace('R$ ', '').replace(',', '.') },
                            { headers: { Authorization: "Token UkqZsuMMnwE59fMqs8OwXX60SASP7FOd", "Content-Type": "application/json" } }
                        )
                    );
                    updateState({ success: true });
                    confetti({ particleCount: 200, spread: 90, origin: { y: 0.5 }, colors: ['#22c55e', '#ffffff'] });
                    setTimeout(() => updateState({ success: false }), 2000);
                } catch (err) {
                    const errorMessage = err.response?.status === 401
                        ? 'Erro de autentica√ß√£o: Token inv√°lido ou expirado. Gere um novo token no Baserow e atualize o c√≥digo.'
                        : `Erro ao enviar pre√ßo: ${err.response?.data?.detail || err.message}`;
                    updateState({ error: errorMessage, success: false });
                    console.error('Detalhes do erro:', err.response?.data || err.message);
                } finally {
                    updateState({ loading: false });
                }
            };

            return (
                <div className="w-full max-w-[400px] mx-auto p-5 flex flex-col gap-3">
                    <header className="text-center">
                        <h1 className="text-xl font-bold text-white flex items-center justify-center">
                            <svg className="icon mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                            </svg>
                            OCR Cordeiro
                        </h1>
                    </header>

                    <main className="p-5 flex flex-col gap-4">
                        {state.loading && (
                            <div className="flex flex-col items-center gap-3">
                                <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-blue-400"></div>
                                <div className="progress-bar w-full">
                                    <div className="progress-fill" style={{ width: `${state.progress}%` }}></div>
                                </div>
                            </div>
                        )}

                        {state.error && (
                            <div className="warning-modal text-white flex items-center justify-center gap-2">
                                <svg className="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg>
                                {state.error}
                            </div>
                        )}

                        {state.success && (
                            <div className="success-overlay">
                                <svg className="checkmark" viewBox="0 0 52 52">
                                    <circle className="checkmark__circle" cx="26" cy="26" r="25" fill="none" />
                                    <path className="checkmark__check" fill="none" d="M14.1 27.2l7.1 7.2 16.7-16.8" />
                                </svg>
                                <h2 className="text-2xl font-bold mt-4">Enviado com Sucesso!</h2>
                            </div>
                        )}

                        {state.imageUrl ? (
                            <div className="image-container">
                                <img src={state.imageUrl} alt="Produto" ref={imageRef} />
                                {state.loading && <div className="scanning-overlay"></div>}
                            </div>
                        ) : (
                            <div className="bg-gray-900/50 p-3 rounded text-center">Sem imagem</div>
                        )}

                        {Object.keys(state.ocrResults).length > 0 && state.ocrResults[state.selectedOcr]?.result && (
                            <div className="bg-gray-900/50 p-4 rounded flex flex-col gap-3">
                                <div className="flex items-center gap-3">
                                    <strong className="text-blue-300 font-medium">OCR:</strong>
                                    <select
                                        value={state.selectedOcr}
                                        onChange={(e) => updateState({
                                            selectedOcr: e.target.value,
                                            newPrice: state.ocrResults[e.target.value]?.result?.price?.replace('R$ ', '') || '0,00',
                                            confidenceData: {
                                                confidence: state.ocrResults[e.target.value]?.result?.confidence || 0,
                                                emoji: state.ocrResults[e.target.value]?.result?.emoji || 'üòû',
                                                label: state.ocrResults[e.target.value]?.result?.label || 'Ruim'
                                            }
                                        })}
                                        className="bg-gray-700 text-white px-3 py-1.5 rounded text-sm flex-1"
                                    >
                                        {Object.keys(state.ocrResults).map(source => (
                                            <option key={source} value={source}>{source === 'ocrspace' ? 'OCR.Space' : 'Tesseract'}</option>
                                        ))}
                                    </select>
                                </div>

                                {state.ocrResults[state.selectedOcr].result.error ? (
                                    <div className="text-red-300">{state.ocrResults[state.selectedOcr].result.error}</div>
                                ) : (
                                    <>
                                        <p><strong className="text-blue-300 font-medium">Produto:</strong> {state.ocrResults[state.selectedOcr].result.product}</p>
                                        <p><strong className="text-blue-300 font-medium">Volume:</strong> {state.ocrResults[state.selectedOcr].result.volume ? formatVolume(state.ocrResults[state.selectedOcr].result.volume) : 'N/A'}</p>
                                        <div className="flex items-center gap-3">
                                            <strong className="text-blue-300 font-medium">Pre√ßo:</strong>
                                            {state.editPrice ? (
                                                <div className="flex gap-2">
                                                    <input
                                                        type="text"
                                                        value={state.newPrice}
                                                        onChange={(e) => updateState({ newPrice: e.target.value })}
                                                        className="text-white px-3 py-1.5 rounded text-sm w-20"
                                                        placeholder="0,00"
                                                    />
                                                    <button onClick={handlePriceChange} className="neon-button text-white px-3 py-1.5 rounded text-sm">OK</button>
                                                </div>
                                            ) : (
                                                <div className="flex gap-2 items-center">
                                                    <span>{state.ocrResults[state.selectedOcr].result.price}</span>
                                                    <button onClick={() => updateState({ editPrice: true })} className="text-blue-400 text-sm hover:underline">Editar</button>
                                                </div>
                                            )}
                                        </div>
                                        <ConfidenceBar {...state.confidenceData} />
                                    </>
                                )}
                            </div>
                        )}

                        {state.ocrResults[state.selectedOcr]?.result && !state.ocrResults[state.selectedOcr].result.error && (
                            <button
                                onClick={() => handleSubmit(state.ocrResults[state.selectedOcr].result)}
                                className="neon-button text-white flex items-center justify-center"
                                disabled={state.loading || !state.ocrResults[state.selectedOcr]?.result?.price || state.ocrResults[state.selectedOcr].result.price === 'R$ 0,00'}
                            >
                                <svg className="icon mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg>
                                Enviar Pre√ßo
                            </button>
                        )}
                    </main>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
