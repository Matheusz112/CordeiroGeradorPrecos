<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCR Cordeiro</title>
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.7.7/dist/axios.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.25.6/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            background: linear-gradient(135deg, #1a1a40, #2e1065);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #e5e7eb;
            font-family: 'Inter', sans-serif;
            font-size: 0.95rem;
            overflow-x: hidden;
            position: relative;
        }
        canvas#particle-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }
        .bubble {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(147, 197, 253, 0.3), transparent);
            box-shadow: 0 0 20px rgba(147, 197, 253, 0.5);
            animation: float 6s infinite ease-in-out;
            pointer-events: none;
        }
        .bubble:nth-child(1) { width: 80px; height: 80px; top: 15%; left: 15%; animation-duration: 6s; }
        .bubble:nth-child(2) { width: 60px; height: 60px; top: 55%; left: 75%; animation-duration: 8s; }
        .bubble:nth-child(3) { width: 70px; height: 70px; top: 65%; left: 25%; animation-duration: 7s; }
        @keyframes float {
            0% { transform: translateY(0) translateX(0); opacity: 0.7; }
            50% { transform: translateY(-60px) translateX(15px); opacity: 1; }
            100% { transform: translateY(0) translateX(0); opacity: 0.7; }
        }
        .image-container {
            height: 200px;
            overflow: hidden;
            position: relative;
            border-radius: 14px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.6), 0 0 30px rgba(147, 197, 253, 0.3);
            background: #fff;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            animation: fadeIn 0.8s ease-out;
        }
        .image-container:hover {
            transform: scale(1.03);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.7), 0 0 40px rgba(147, 197, 253, 0.5);
        }
        .image-container img {
            width: 100%;
            height: auto;
            object-fit: contain;
            object-position: center;
        }
        .scanning-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, transparent, #a5b4fc, transparent);
            animation: scanWave 0.8s infinite ease-in-out;
        }
        @keyframes scanWave {
            0% { transform: translateY(0); opacity: 0.7; }
            50% { transform: translateY(200px); opacity: 1; }
            100% { transform: translateY(0); opacity: 0.7; }
        }
        .icon {
            width: 26px;
            height: 26px;
            vertical-align: middle;
        }
        .neon-button {
            background: linear-gradient(45deg, #3b82f6, #a855f7);
            box-shadow: 0 0 12px rgba(59, 130, 246, 0.8), 0 0 24px rgba(168, 85, 247, 0.6);
            transition: all 0.3s ease;
            border-radius: 12px;
            padding: 14px 30px;
            font-weight: 600;
            font-size: 1rem;
            animation: pulse 2.5s infinite ease-in-out;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .neon-button:hover:not(:disabled) {
            box-shadow: 0 0 20px rgba(59, 130, 246, 1), 0 0 30px rgba(168, 85, 247, 0.8);
            transform: scale(1.05);
        }
        .neon-button:disabled {
            background: #4b5563;
            box-shadow: none;
            cursor: not-allowed;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 12px rgba(59, 130, 246, 0.8), 0 0 24px rgba(168, 85, 247, 0.6); }
            50% { box-shadow: 0 0 18px rgba(59, 130, 246, 1), 0 0 36px rgba(168, 85, 247, 0.8); }
            100% { box-shadow: 0 0 12px rgba(59, 130, 246, 0.8), 0 0 24px rgba(168, 85, 247, 0.6); }
        }
        .success-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #10b981, #059669);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            animation: popIn 1s ease-out, fadeOut 1s ease-out 6s forwards;
            z-index: 1000;
            backdrop-filter: blur(8px);
        }
        .success-overlay h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            font-weight: 700;
            text-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
            animation: waveText 1.2s ease-out;
        }
        .success-overlay p {
            font-size: 1.3rem;
            font-weight: 500;
            margin-top: 1.5rem;
            max-width: 600px;
            text-align: center;
            animation: waveText 1.2s ease-out 0.3s;
        }
        .checkmark {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            stroke-width: 3;
            stroke: #fff;
            stroke-miterlimit: 10;
            animation: fill 0.6s ease-in-out 0.6s forwards, scale 0.5s ease-in-out 1.2s both;
        }
        .checkmark__circle {
            stroke-dasharray: 166;
            stroke-dashoffset: 166;
            stroke-width: 3;
            stroke: #22c55e;
            fill: none;
            animation: stroke 0.8s cubic-bezier(0.65, 0, 0.45, 1) forwards;
        }
        .checkmark__check {
            transform-origin: 50% 50%;
            stroke-dasharray: 48;
            stroke-dashoffset: 48;
            animation: stroke 0.5s cubic-bezier(0.65, 0, 0.45, 1) 1s forwards;
        }
        @keyframes stroke {
            100% { stroke-dashoffset: 0; }
        }
        @keyframes scale {
            0%, 100% { transform: none; }
            50% { transform: scale3d(1.4, 1.4, 1); }
        }
        @keyframes fill {
            100% { box-shadow: inset 0px 0px 0px 60px #22c55e; }
        }
        @keyframes popIn {
            0% { transform: scale(0.6); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes waveText {
            0% { transform: translateY(30px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }
        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        @keyframes glow {
            0% { text-shadow: 0 0 5px rgba(168, 85, 247, 0.5); }
            50% { text-shadow: 0 0 15px rgba(168, 85, 247, 0.8); }
            100% { text-shadow: 0 0 5px rgba(168, 85, 247, 0.5); }
        }
        .progress-bar {
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #a855f7);
            transition: width 0.5s ease;
        }
        .confidence-bar {
            height: 12px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            overflow: hidden;
            animation: slideIn 0.8s ease-out;
        }
        .confidence-fill {
            height: 100%;
            background: linear-gradient(to right, #f43f5e, #facc15, #22c55e);
            transition: width 0.5s ease;
        }
        .confidence-label {
            font-size: 0.9rem;
            color: #e5e7eb;
            text-align: center;
            margin-top: 10px;
            font-weight: 500;
            animation: glow 2s infinite ease-in-out;
        }
        .warning-modal {
            animation: popIn 0.6s ease-out;
            background: rgba(239, 68, 68, 0.95);
            border-radius: 12px;
            padding: 14px;
            text-align: center;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }
        .text-bbox-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        main {
            background: rgba(17, 24, 39, 0.8);
            border-radius: 14px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.6);
            padding: 2rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            animation: fadeIn 0.8s ease-out;
        }
        select, input {
            background: rgba(31, 41, 55, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: white;
            padding: 10px;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        select:focus, input:focus {
            outline: none;
            border-color: #a855f7;
            box-shadow: 0 0 12px rgba(168, 85, 247, 0.5);
        }
        .header {
            background: linear-gradient(90deg, #3b82f6, #a855f7);
            padding: 1.2rem;
            border-radius: 14px 14px 0 0;
            margin: -2rem -2rem 1.5rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
        }
        .product-label, .price-label {
            animation: slideIn 0.8s ease-out;
        }
        @keyframes fadeIn {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideIn {
            0% { opacity: 0; transform: translateX(-20px); }
            100% { opacity: 1; transform: translateX(0); }
        }
    </style>
</head>
<body>
    <canvas id="particle-bg"></canvas>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div id="root"></div>
    <script>
        // Particle background
        const canvas = document.getElementById('particle-bg');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const particles = [];
        for (let i = 0; i < 100; i++) {
            particles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                radius: Math.random() * 2 + 1,
                speed: Math.random() * 0.5 + 0.2
            });
        }

        function animateParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            particles.forEach(p => {
                p.y += p.speed;
                if (p.y > canvas.height) p.y = 0;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            requestAnimationFrame(animateParticles);
        }
        animateParticles();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        window.addEventListener('error', (event) => {
            console.error('Erro global:', event.message, event.filename, event.lineno, event.colno, event.error?.stack || 'No stack trace');
            document.getElementById('root').innerHTML = `
                <div class="bg-red-900/50 text-red-300 p-4 rounded text-center">
                    Erro cr√≠tico: ${event.message}. Verifique o console.
                </div>
            `;
        });

        function preprocessImage(base64Image, callback) {
            const img = new Image();
            img.src = `data:image/jpeg;base64,${base64Image}`;
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                callback(canvas.toDataURL('image/jpeg', 0.95).split(',')[1]);
            };
            img.onerror = () => callback(null);
        }

        function drawTextBoundingBoxes(imageElement, words) {
            const existingCanvas = imageElement.parentElement.querySelector('.text-bbox-canvas');
            if (existingCanvas) existingCanvas.remove();

            const canvas = document.createElement('canvas');
            canvas.className = 'text-bbox-canvas';
            const ctx = canvas.getContext('2d');
            const container = imageElement.parentElement;

            const rect = imageElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;

            const scaleX = rect.width / imageElement.naturalWidth;
            const scaleY = rect.height / imageElement.naturalHeight;

            container.style.position = 'relative';
            container.appendChild(canvas);

            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2.5;
            words.forEach(word => {
                if (word.bbox && word.confidence >= 50) {
                    const { x0, y0, x1, y1 } = word.bbox;
                    const isVolume = word.text.match(/(\d+)(ML|L|LT|LTR|LTRO|LITRO)/i) || knownVolumes.includes(parseInt(word.text));
                    const isPrice = word.text.match(/(R\$)?\s*\d+[,.]\d{2}/) || word.text.match(/\d+[,.]\d{2}/);

                    if (isVolume || isPrice) {
                        ctx.strokeStyle = '#22c55e'; // Green for volume and price
                        ctx.lineWidth = 3.5;
                    } else {
                        ctx.strokeStyle = 'red'; // Red for other text
                        ctx.lineWidth = 2.5;
                    }

                    ctx.beginPath();
                    ctx.rect(x0 * scaleX, y0 * scaleY, (x1 - x0) * scaleX, (y1 - y0) * scaleY);
                    ctx.stroke();
                }
            });
        }
    </script>
    <script type="text/babel">
        const bancoDeDados = [
            { id: 3, PRODUTO: 'CERV LAGER HEINEKEN LN 6X330ml', ML: 330, brand: 'HEINEKEN' },
            { id: 4, PRODUTO: 'CERV STELLA ARTOIS LN 6X330ml', ML: 330, brand: 'STELLA ARTOIS' },
            { id: 5, PRODUTO: 'CERV LAGER CORONA LN 6X330ml', ML: 330, brand: 'CORONA' },
            { id: 6, PRODUTO: 'CERV LAGER BUDWEISER LN 6X330ml', ML: 330, brand: 'BUDWEISER' },
            { id: 7, PRODUTO: 'CERV HEINEKEN ZERO ALC LN 6X330ml', ML: 330, brand: 'HEINEKEN' },
            { id: 8, PRODUTO: 'CERV P MALTE SPATEM LN 6X355ml', ML: 355, brand: 'SPATEM' },
            { id: 9, PRODUTO: 'CERV BRAHMA ZERO √ÅLCOOL 12X350ml', ML: 350, brand: 'BRAHMA' },
            { id: 10, PRODUTO: 'CERV HEINEKEN ZERO √ÅLCOOL 12X350ml', ML: 350, brand: 'HEINEKEN' },
            { id: 11, PRODUTO: 'CERV EISENBAHN 12X473ml', ML: 473, brand: 'EISENBAHN' },
            { id: 12, PRODUTO: 'CERVEJA LAGER AMSTEL 12X473ml', ML: 473, brand: 'AMSTEL' },
            { id: 13, PRODUTO: 'CERV HEINEKEN LT 12X473ml', ML: 473, brand: 'HEINEKEN' },
            { id: 14, PRODUTO: 'CERVEJA KAISER 12X473ml', ML: 473, brand: 'KAISER' },
            { id: 15, PRODUTO: 'CERV PILSEN ANTARTICA 12X473ml', ML: 473, brand: 'ANTARTICA' },
            { id: 16, PRODUTO: 'CERV ANTARCTICA ORIGINAL 12X473ml', ML: 473, brand: 'ANTARTICA' },
            { id: 17, PRODUTO: 'CERVEJA BRAHMA 12X473ml', ML: 473, brand: 'BRAHMA' },
            { id: 18, PRODUTO: 'CERVEJA STELLA ARTOIS 12X473ml', ML: 473, brand: 'STELLA ARTOIS' },
            { id: 19, PRODUTO: 'CERVEJA P MALTE BOHEMIA 473ml', ML: 473, brand: 'BOHEMIA' },
            { id: 20, PRODUTO: 'CERV P MALTE SPATEM LT 12X473ml', ML: 473, brand: 'SPATEM' },
            { id: 21, PRODUTO: 'CERV ANTARCTICA SUB ZERO 473ml', ML: 473, brand: 'ANTARTICA' },
            { id: 22, PRODUTO: 'LEITE ITAMB√ä INTEGRAL 12X1L', ML: 1, brand: 'ITAMB√ä' },
            { id: 23, PRODUTO: 'LEITE ITAMB√ä DESNATADO 12X1L', ML: 1, brand: 'ITAMB√ä' },
            { id: 24, PRODUTO: 'LEITE ITAMB√ä SEMIDESNATADO 12X1L', ML: 1, brand: 'ITAMB√ä' },
            { id: 25, PRODUTO: 'LEITE PORTO ALEGRE INTEGRAL 12X1L', ML: 1, brand: 'PORTO ALEGRE' },
            { id: 26, PRODUTO: 'LEITE QUATA INTEGRAL 12X1L', ML: 1, brand: 'QUATA' },
            { id: 27, PRODUTO: 'LEITE PIRACANJUBA INTEGRAL 12X1L', ML: 1, brand: 'PIRACANJUBA' },
            { id: 28, PRODUTO: '√ÅGUA IGARAPE SEM G√ÅS 12X500ml', ML: 500, brand: 'IGARAPE' },
            { id: 29, PRODUTO: '√ÅGUA IGARAP√â COM G√ÅS 12X500ml', ML: 500, branch: 'IGARAPE' },
            { id: 30, PRODUTO: 'REFRI COCA COLA MINI PET 12X200ml', ML: 200, brand: 'COCA COLA' },
            { id: 31, PRODUTO: 'REFRI SUKITA LARANJA PET 12X200ml', ML: 200, brand: 'SUKITA' },
            { id: 32, PRODUTO: 'REFRI SODA LIMONADA PET 12X200ml', ML: 200, brand: 'SODA' },
            { id: 33, PRODUTO: 'REFRI GUARAN√Å ANTARTICA PET 12X200ml', ML: 200, brand: 'GUARAN√Å ANTARTICA' },
            { id: 34, PRODUTO: 'REFRI GUARAN√Å ZERO PET 12X200ml', ML: 200, brand: 'GUARAN√Å ANTARTICA' },
            { id: 35, PRODUTO: 'REFRI PEPSI PET 12X200ml', ML: 200, brand: 'PEPSI' },
            { id: 36, PRODUTO: '√ìLEO DE SOJA VELEIRO 6X900ml', ML: 900, brand: 'VELEIRO' },
            { id: 37, PRODUTO: '√ìLEO DE SOJA LIZA 6X900ml', ML: 900, brand: 'LIZA' },
            { id: 38, PRODUTO: 'CERV MALZBIER BRAHMA 6X355ml', ML: 355, brand: 'BRAHMA' },
            { id: 39, PRODUTO: 'CERV PILSEN IMPERIO 12X473ml', ML: 473, brand: 'IMPERIO' },
            { id: 40, PRODUTO: 'CERV PILSEN BUDWEISER 12X473ml', ML: 473, brand: 'BUDWEISER' },
            { id: 67, PRODUTO: 'LEITE INTEGRAL ITA 12X1L', ML: 1, brand: 'ITA' },
            { id: 68, PRODUTO: 'LEITE INTEGRAL ITALAC 12X1L', ML: 1, brand: 'ITALAC' },
            { id: 69, PRODUTO: 'AGUA MIN GRAO MOGOL 12X500ml', ML: 500, brand: 'GRAO MOGOL' },
            { id: 70, PRODUTO: 'CERV P MALTE SPATEM LN 6X355ml', ML: 355, brand: 'SPATEM' },
            { id: 71, PRODUTO: 'CERV LAGER HEINEKEN LN 6X355ml', ML: 355, brand: 'HEINEKEN' },
            { id: 72, PRODUTO: 'CERV PILSEN BRUDER BX GASTRO 12X473ml', ML: 473, brand: 'BRUDER' },
            { id: 73, PRODUTO: 'CERV PILSEN LAUT 12X473ml', ML: 473, brand: 'LAUT' },
            { id: 74, PRODUTO: 'CERV P MALTE PETRA 12X473ml', ML: 473, brand: 'PETRA' },
            { id: 75, PRODUTO: 'CERV PILSEN ITAIPAVA LT 12X473ml', ML: 473, brand: 'ITAIPAVA' },
            { id: 76, PRODUTO: 'CERV PILSEN SKOL LT 12X473ml', ML: 473, brand: 'SKOL' },
            { id: 100, PRODUTO: 'CERV LAGER CORONA LN 6X330ml', ML: 330, brand: 'CORONA' },
            { id: 133, PRODUTO: 'CERV LAGER BUDWEISER LN 6X330ml', ML: 330, brand: 'BUDWEISER' },
            { id: 167, PRODUTO: 'CERV PILSEN LAUT 12X473ml', ML: 473, brand: 'LAUT' },
            { id: 199, PRODUTO: 'REFRI CA√áULINHA SODA 12X200ml', ML: 200, brand: 'CA√áULINHA' },
            { id: 232, PRODUTO: 'CERV LAGER HEINEKEN LN 6X330ml', ML: 330, brand: 'HEINEKEN' },
            { id: 233, PRODUTO: 'CERV LAGER HEINEKEN LN 6X330ml', ML: 330, brand: 'HEINEKEN' },
            { id: 265, PRODUTO: 'CERVEJA KAISER 12X473ml', ML: 473, brand: 'KAISER' },
            { id: 266, PRODUTO: 'CERV MALZIBIER CARACU 12X350ml', ML: 350, brand: 'CARACU' },
            { id: 298, PRODUTO: 'LEITE INTEGRAL CEMIL 12X1L', ML: 1, brand: 'CEMIL' },
            { id: 331, PRODUTO: 'CERV ZERO ALC BUDWEISER LN 6x330ml', ML: 330, brand: 'BUDWEISER' },
            { id: 364, PRODUTO: 'CERV AMERICA IPA EISENBAHN LN 6X355ml', ML: 355, brand: 'EISENBAHN' },
            { id: 65, PRODUTO: 'CERV PALE ALE EISENBAHN LN 6X355ml', ML: 355, brand: 'EISENBAHN' },
            { id: 366, PRODUTO: 'CERV PILSEN BRAHMA LN 6X355ml', ML: 355, brand: 'BRAHMA' },
            { id: 367, PRODUTO: 'CERV UTRA AMSTEL LN 6X275ml', ML: 275, brand: 'AMSTEL' },
            { id: 368, PRODUTO: 'FANTA LARANJA ZERO 12x2l', ML: 2, brand: 'FANTA' },
            { id: 397, PRODUTO: 'COQ COROTE LIM√ÉO 12X500ml', ML: 500, brand: 'COROTE' }
        ];

        const keywords = [
            'CERV', 'CERVEJA', 'LAGER', 'PILSEN', 'ZERO', 'ALC', '√ÅLCOOL', 'MALTE', 'ORIGINAL', 'SUB', 'LN', 'LONG NECK',
            'LEITE', 'INTEGRAL', 'DESNATADO', 'SEMIDESNATADO', 'AGUA', 'GAS', 'REFRI', 'SODA',
            'LIMONADA', 'GUARANA', 'OLEO', 'SOJA', 'MALZBIER', 'IPA', 'PALE', 'ALE', 'UTRA'
        ];

        const brandPrefixes = [
            { prefix: 'HEI', brand: 'HEINEKEN', score: 100 },
            { prefix: 'STE', brand: 'STELLA ARTOIS', score: 100 },
            { prefix: 'COR', brand: 'CORONA', score: 100 },
            { prefix: 'BUD', brand: 'BUDWEISER', score: 100 },
            { prefix: 'SPA', brand: 'SPATEM', score: 100 },
            { prefix: 'BRA', brand: 'BRAHMA', score: 100 },
            { prefix: 'EIS', brand: 'EISENBAHN', score: 100 },
            { prefix: 'AMS', brand: 'AMSTEL', score: 100 },
            { prefix: 'KAI', brand: 'KAISER', score: 100 },
            { prefix: 'ANT', brand: 'ANTARTICA', score: 100 },
            { prefix: 'BOH', brand: 'BOHEMIA', score: 100 },
            { prefix: 'ITA', brand: 'ITAIPAVA', score: 100 },
            { prefix: 'SKO', brand: 'SKOL', score: 100 },
            { prefix: 'PET', brand: 'PETRA', score: 100 },
            { prefix: 'LAU', brand: 'LAUT', score: 100 },
            { prefix: 'BRU', brand: 'BRUDER', score: 100 },
            { prefix: 'ITAM', brand: 'ITAMB√ä', score: 100 },
            { prefix: 'PORTO', brand: 'PORTO ALEGRE', score: 100 },
            { prefix: 'QUA', brand: 'QUATA', score: 100 },
            { prefix: 'PIR', brand: 'PIRACANJUBA', score: 100 },
            { prefix: 'IGA', brand: 'IGARAPE', score: 100 },
            { prefix: 'COC', brand: 'COCA COLA', score: 100 },
            { prefix: 'SUK', brand: 'SUKITA', score: 100 },
            { prefix: 'GUA', brand: 'GUARAN√Å ANTARTICA', score: 100 },
            { prefix: 'PEP', brand: 'PEPSI', score: 100 },
            { prefix: 'VELE', brand: 'VELEIRO', score: 100 },
            { prefix: 'LIZ', brand: 'LIZA', score: 100 },
            { prefix: 'CAR', brand: 'CARACU', score: 100 },
            { prefix: 'CEM', brand: 'CEMIL', score: 100 },
            { prefix: 'FAN', brand: 'FANTA', score: 100 },
            { prefix: 'COQ', brand: 'COROTE', score: 100 }
        ];

        const knownVolumes = [473, 330, 350, 500, 200, 900, 1, 355, 275, 2];

        function formatVolume(ml) {
            if (ml <= 2) {
                return `${ml}L`;
            }
            return `${ml}ml`;
        }

        function calculatePriceConfidence(price, rawText) {
            let score = 0;
            if (/R\$\s*\d+[,.]\d{2}/.test(rawText)) score += 50;
            else if (/\d+[,.]\d{2}/.test(price)) score += 30;
            else if (/\d+[,.]\d/.test(price)) score += 20;
            else if (/^\d+$/.test(price) && !knownVolumes.includes(parseInt(price))) score += 10;
            if (/(PRE√áO|VALOR|R\$)/i.test(rawText)) score += 15;
            const confidence = Math.min(100, score);
            const emoji = confidence >= 95 ? 'üòé' : confidence >= 85 ? 'üòä' : confidence >= 50 ? 'üòê' : 'üòû';
            const label = confidence >= 95 ? 'Muito Bom' : confidence >= 85 ? 'Bom' : confidence >= 50 ? 'M√©dio' : 'Ruim';
            console.log('Price Confidence:', { confidence, emoji, label });
            return { confidence, emoji, label };
        }

        function calculateProductConfidence(normalizedText, matchedProduct, volumeMatch) {
            let score = 0;
            const normalizedProduct = normalizeText(matchedProduct.PRODUTO);
            const productWords = normalizedProduct.split(' ');
            const textWords = normalizedText.split(' ');
            const volume = volumeMatch ? parseInt(volumeMatch[1]) : null;
            const isLiter = volumeMatch && /L|LT|LTR|LTRO|LITRO/i.test(volumeMatch[2]);

            // Exact brand match
            if (normalizedText.includes(normalizeText(matchedProduct.brand))) {
                score += 200;
            } else {
                brandPrefixes.forEach(({ prefix, brand }) => {
                    if (normalizedText.includes(prefix) && normalizeText(matchedProduct.brand).includes(brand)) {
                        score += 150;
                    }
                });
            }

            // Specific descriptors for Heineken variants
            const descriptors = ['ZERO', 'ALC', '√ÅLCOOL', 'LN', 'LONG NECK'];
            descriptors.forEach(desc => {
                if (normalizedText.includes(desc) && normalizedProduct.includes(desc)) {
                    score += 100; // Exact descriptor match
                } else if (normalizedText.includes(desc) !== normalizedProduct.includes(desc)) {
                    score -= 50; // Penalize mismatch in critical descriptors
                }
            });

            // Keyword matches
            productWords.forEach(word => {
                if (textWords.includes(word)) {
                    score += keywords.includes(word) ? 40 : 15;
                }
            });

            // Exact volume match
            if (volume) {
                if (isLiter && matchedProduct.ML <= 2 && volume === matchedProduct.ML) {
                    score += 150;
                } else if (!isLiter && matchedProduct.ML === volume) {
                    score += 120;
                }
                if (knownVolumes.includes(volume)) score += 30;
            }

            // Description similarity
            const similarity = productWords.filter(word => textWords.includes(word)).length / productWords.length;
            if (similarity >= 0.9) {
                score += 100; // Near-exact match
            } else if (similarity >= 0.7) {
                score += 50; // High similarity
            } else if (similarity >= 0.5) {
                score += 30; // Moderate similarity
            }

            // Ensure 100% confidence only for exact matches
            const isExactMatch = normalizedText.includes(normalizeText(matchedProduct.brand)) &&
                                 volume === matchedProduct.ML &&
                                 similarity >= 0.9 &&
                                 descriptors.every(desc => normalizedText.includes(desc) === normalizedProduct.includes(desc));

            const confidence = isExactMatch ? 100 : Math.min(100, Math.max(50, Math.round(score / 3)));
            const emoji = confidence === 100 ? 'üî•' : confidence >= 95 ? 'üòé' : confidence >= 85 ? 'üòä' : confidence >= 50 ? 'üòê' : 'üòû';
            const label = confidence === 100 ? 'Perfeito' : confidence >= 95 ? 'Muito Bom' : confidence >= 85 ? 'Bom' : confidence >= 50 ? 'M√©dio' : 'Ruim';
            console.log('Product Confidence:', { confidence, emoji, label });
            return { confidence, emoji, label };
        }

        function validatePrice(price, isCervProduct, rawText) {
            if (!price || /R\$\s*0,00/i.test(rawText)) {
                return { price: '0,00', confidence: 0, emoji: 'üòû', label: 'Ruim' };
            }

            let numPrice;
            const volumeLike = ['473', '330', '350', '500', '200', '900', '1', '355', '275', '2'];
            price = price.replace(',', '.').replace(/[^\d.]/g, '');
            if (/^\d+$/.test(price) && volumeLike.includes(price)) {
                price = '0,00';
            } else if (/^\d+[,.]\d{2}$/.test(price)) {
                price = price.replace('.', ',');
            } else if (/^\d+[,.]\d$/.test(price)) {
                price = `${price[0]},${price.slice(2) || '0'}0`;
            } else if (/^\d+$/.test(price)) {
                price = `${price},00`;
            } else {
                price = '0,00';
            }
            numPrice = parseFloat(price.replace(',', '.'));
            if (isNaN(numPrice)) {
                return { price: '0,00', confidence: 0, emoji: 'üòû', label: 'Ruim' };
            }
            if (isCervProduct && numPrice < 0.20) {
                return { price: '0,00', confidence: 0, emoji: 'üòû', label: 'Ruim' };
            }
            if (numPrice > 12.00) {
                numPrice = 12.00;
            }
            const finalPrice = numPrice.toFixed(2).replace('.', ',');
            const { confidence, emoji, label } = calculatePriceConfidence(finalPrice, rawText);
            return { price: finalPrice, confidence, emoji, label };
        }

        function correctOcrText(text) {
            if (typeof text !== 'string') {
                console.warn('correctOcrText: Input n√£o √© uma string, retornando vazio', text);
                return '';
            }
            const corrections = [
                { wrong: /\b[Ss](?=\d*[,.]\d)/gi, correct: '5' },
                { wrong: /\b[Oo](?=\d*[,.]\d)/gi, correct: '0' },
                { wrong: /\b(RS|RZ|S)\b/gi, correct: 'R$' },
                { wrong: /\b(\d+)[,.](\d{1,2})\b/gi, correct: '$1,$2' },
                { wrong: /\bHE1NEKEN\b/gi, correct: 'HEINEKEN' },
                { wrong: /\bSTEL1A\b/gi, correct: 'STELLA' },
                { wrong: /\bC0R0NA\b/gi, correct: 'CORONA' },
                { wrong: /\bBUDWE1SER\b/gi, correct: 'BUDWEISER' },
                { wrong: /\bSPATEN\b/gi, correct: 'SPATEM' },
                { wrong: /\bBRAMA\b/gi, correct: 'BRAHMA' },
                { wrong: /\bE1SENBAHN\b/gi, correct: 'EISENBAHN' },
                { wrong: /\bAMST3L\b/gi, correct: 'AMSTEL' },
                { wrong: /\bKA1SER\b/gi, correct: 'KAISER' },
                { wrong: /\bANTART1CA\b/gi, correct: 'ANTARTICA' },
                { wrong: /\bB0HEMIA\b/gi, correct: 'BOHEMIA' },
                { wrong: /\bSK0L\b/gi, correct: 'SKOL' },
                { wrong: /\b1TA1PAVA\b/gi, correct: 'ITAIPAVA' },
                { wrong: /\b(LT|LTR|LTRO)\b/gi, correct: 'LITRO' },
                { wrong: /\bC00\b/gi, correct: 'COQ' },
                { wrong: /\bC0Q\b/gi, correct: 'COQ' },
                { wrong: /\bC0R0TE\b/gi, correct: 'COROTE' },
                { wrong: /\bLIMAO\b/gi, correct: 'LIM√ÉO' },
                { wrong: /\b0LEO\b/gi, correct: '√ìLEO' }
            ];
            let corrected = text;
            corrections.forEach(({ wrong, correct }) => {
                corrected = corrected.replace(wrong, correct);
            });
            return corrected;
        }

        function normalizeText(text) {
            if (typeof text !== 'string') {
                console.warn('normalizeText: Input n√£o √© uma string, retornando vazio', text);
                return '';
            }
            return text
                .toUpperCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                .replace(/\s+/g, ' ')
                .replace(/[^A-Z0-9\s]/g, '')
                .trim();
        }

        function findBestMatch(normalizedText, database) {
            const volumeMatch = normalizedText.match(/(\d+)(ML|L|LT|LTR|LTRO|LITRO)/i);
            const volume = volumeMatch ? parseInt(volumeMatch[1]) : null;
            const isLiter = volumeMatch && /L|LT|LTR|LTRO|LITRO/i.test(volumeMatch[2]);
            const textWords = normalizedText.split(' ');
            let bestMatch = null;
            let highestScore = -Infinity;
            let currentDatabase = [...database];
            const penalizedIds = new Set();
            let iteration = 0;

            while (currentDatabase.length > 0 && iteration < 3) {
                const scores = [];
                let hasPenalty = false;

                // Score all products in the current database
                currentDatabase.forEach(product => {
                    const normalizedProduct = normalizeText(product.PRODUTO);
                    const productWords = normalizedProduct.split(' ');
                    let score = 0;

                    // Brand match
                    if (normalizedText.includes(normalizeText(product.brand))) {
                        score += 200;
                    } else {
                        brandPrefixes.forEach(({ prefix, brand }) => {
                            if (normalizedText.includes(prefix) && normalizeText(product.brand).includes(brand)) {
                                score += 150;
                            }
                        });
                    }

                    // Specific descriptors for Heineken variants
                    const descriptors = ['ZERO', 'ALC', '√ÅLCOOL', 'LN', 'LONG NECK'];
                    descriptors.forEach(desc => {
                        if (normalizedText.includes(desc) && normalizedProduct.includes(desc)) {
                            score += 100;
                        } else if (normalizedText.includes(desc) !== normalizedProduct.includes(desc)) {
                            score -= 50; // Penalize mismatch
                            penalizedIds.add(product.id);
                            hasPenalty = true;
                        }
                    });

                    // Keyword matches
                    productWords.forEach(word => {
                        if (textWords.includes(word)) {
                            score += keywords.includes(word) ? 40 : 15;
                        }
                    });

                    // Volume match
                    if (volume) {
                        if (isLiter && product.ML <= 2 && volume === product.ML) {
                            score += 150;
                        } else if (!isLiter && product.ML === volume) {
                            score += 120;
                        }
                        if (knownVolumes.includes(volume)) score += 30;
                    }

                    // Description similarity
                    const similarity = productWords.filter(word => textWords.includes(word)).length / productWords.length;
                    if (similarity >= 0.9) {
                        score += 100;
                    } else if (similarity >= 0.7) {
                        score += 50;
                    } else if (similarity >= 0.5) {
                        score += 30;
                    }

                    scores.push({ product: product.PRODUTO, id: product.id, score, similarity: similarity.toFixed(2) });
                });

                // Sort scores and check for close matches
                scores.sort((a, b) => b.score - a.score);
                console.log(`Itera√ß√£o ${iteration + 1} Scores:`, scores);
                console.log(`Penalizados:`, Array.from(penalizedIds));

                if (scores.length > 0) {
                    bestMatch = currentDatabase.find(p => normalizeText(p.PRODUTO) === normalizeText(scores[0].product));
                    highestScore = scores[0].score;

                    // Check if top match is valid and not ambiguous
                    if (highestScore >= 100 && (!hasPenalty || scores[0].score - (scores[1]?.score || 0) >= 5)) {
                        console.log(`Melhor correspond√™ncia encontrada na itera√ß√£o ${iteration + 1}:`, bestMatch);
                        return bestMatch;
                    }
                }

                // Filter out penalized products and retry
                currentDatabase = currentDatabase.filter(p => !penalizedIds.has(p.id));
                iteration++;
            }

            console.warn('Nenhuma correspond√™ncia v√°lida encontrada ap√≥s todas as itera√ß√µes. Retornando padr√£o:', bancoDeDados[0]);
            return bancoDeDados[0];
        }

        async function retryOperation(fn, maxRetries = 2, delay = 300) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    return await fn();
                } catch (err) {
                    console.error(`Tentativa ${attempt} falhou: ${err.message}`);
                    if (attempt === maxRetries) throw err;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        function ConfidenceBar({ confidence, emoji, label }) {
            return (
                <div className="animate-[slideIn_0.8s_ease-out]">
                    <div className="confidence-bar">
                        <div className="confidence-fill" style={{ width: `${confidence}%` }}></div>
                    </div>
                    <div className="confidence-label">{emoji} {label} ({confidence}%)</div>
                </div>
            );
        }

        function App() {
            const [state, setState] = React.useState({
                imageUrl: '',
                ocrResults: {},
                loading: false,
                error: null,
                editPrice: false,
                newPrice: '',
                success: false,
                successMessage: '',
                priceDetected: false,
                progress: 0
            });
            const imageRef = React.useRef(null);

            const updateState = (updates) => setState(prev => ({ ...prev, ...updates }));

            React.useEffect(() => {
                const fetchImage = async () => {
                    updateState({ loading: true });
                    try {
                        const response = await retryOperation(() =>
                            axios.get(
                                "https://api.baserow.io/api/database/rows/table/587819/2/?user_field_names=true",
                                { headers: { Authorization: "Token UkqZsuMMnwE59fMqs8OwXX60SASP7FOd" } }
                            )
                        );
                        updateState({ imageUrl: response.data.urlimagem });
                    } catch (err) {
                        updateState({ error: `Erro ao buscar imagem: ${err.message}` });
                    } finally {
                        updateState({ loading: false });
                    }
                };
                fetchImage();
            }, []);

            React.useEffect(() => {
                if (state.imageUrl) processImage(state.imageUrl);
            }, [state.imageUrl]);

            React.useEffect(() => {
                if (imageRef.current && state.ocrResults.ocrspace?.result?.words?.length > 0) {
                    drawTextBoundingBoxes(imageRef.current, state.ocrResults.ocrspace.result.words);
                }
            }, [state.ocrResults]);

            const processImage = async (url) => {
                updateState({ loading: true, error: null, progress: 0 });
                try {
                    const response = await retryOperation(() =>
                        axios.get(url, { responseType: 'blob', timeout: 15000 })
                    );
                    const reader = new FileReader();
                    reader.readAsDataURL(response.data);
                    reader.onloadend = () => {
                        const base64Image = reader.result.split(',')[1];
                        preprocessImage(base64Image, async (processedImage) => {
                            if (!processedImage) {
                                updateState({ error: 'Erro ao preprocessar imagem', loading: false });
                                return;
                            }
                            try {
                                const formData = new FormData();
                                formData.append('base64Image', `data:image/jpeg;base64,${processedImage}`);
                                formData.append('language', 'por');
                                formData.append('isOverlayRequired', 'true');
                                formData.append('OCREngine', '2');
                                formData.append('scale', 'true');
                                formData.append('detectOrientation', 'true');
                                const ocrSpaceResponse = await retryOperation(() =>
                                    axios.post('https://api.ocr.space/parse/image', formData, {
                                        headers: { 'apikey': 'K86154304788957', 'Content-Type': 'multipart/form-data' },
                                        timeout: 15000
                                    })
                                );
                                updateState({ progress: 100 });
                                const ocrText = ocrSpaceResponse.data?.ParsedResults?.[0]?.ParsedText || '';
                                if (!ocrText && ocrSpaceResponse.data) {
                                    console.warn('OCR.Space retornou resposta inv√°lida:', ocrSpaceResponse.data);
                                }
                                const correctedText = correctOcrText(ocrText);
                                const normalizedText = normalizeText(correctedText);
                                let ocrPrice = correctedText.match(/(R\$)?\s*\d+[,.]\d{2}/)?.[0] || 
                                              correctedText.match(/(R\$)?\s*\d+[,.]\d/)?.[0] || '';
                                ocrPrice = ocrPrice.replace(/R\$/, '').trim();
                                if (!ocrPrice) ocrPrice = '0,00';
                                const volumeMatch = normalizedText.match(/(\d+)(ML|L|LT|LTR|LTRO|LITRO)/i);
                                const matchedProduct = findBestMatch(normalizedText, bancoDeDados);
                                const isCervProduct = normalizedText.includes('CERV') || normalizedText.includes('CERVEJA');
                                const { price: validatedPrice, confidence: priceConfidence, emoji: priceEmoji, label: priceLabel } = validatePrice(ocrPrice, isCervProduct, correctedText);
                                const { confidence: productConfidence, emoji: productEmoji, label: productLabel } = calculateProductConfidence(normalizedText, matchedProduct, volumeMatch);
                                const words = ocrSpaceResponse.data?.ParsedResults?.[0]?.TextOverlay?.Lines?.flatMap(line =>
                                    line.Words.map(word => ({
                                        text: word.WordText,
                                        confidence: word.Confidence || 50,
                                        bbox: {
                                            x0: word.Left,
                                            y0: word.Top,
                                            x1: word.Left + word.Width,
                                            y1: word.Top + word.Height
                                        }
                                    }))
                                ) || [];
                                const results = {
                                    ocrspace: {
                                        result: {
                                            product: matchedProduct.PRODUTO,
                                            volume: matchedProduct.ML,
                                            price: `R$ ${validatedPrice}`,
                                            id: matchedProduct.id,
                                            rawText: correctedText,
                                            confidence: Math.max(priceConfidence, productConfidence),
                                            emoji: productConfidence >= priceConfidence ? productEmoji : priceEmoji,
                                            label: productConfidence >= priceConfidence ? productLabel : priceLabel,
                                            words
                                        }
                                    }
                                };
                                updateState({
                                    ocrResults: results,
                                    newPrice: results.ocrspace.result.price.replace('R$ ', ''),
                                    confidenceData: { confidence: results.ocrspace.result.confidence, emoji: results.ocrspace.result.emoji, label: results.ocrspace.result.label },
                                    loading: false
                                });
                                if (results.ocrspace.result.price !== 'R$ 0,00') {
                                    updateState({ priceDetected: true });
                                    confetti({ 
                                        particleCount: 250, 
                                        spread: 100, 
                                        origin: { y: 0.6 },
                                        colors: ['#3b82f6', '#a855f7', '#ffffff'],
                                        ticks: 350
                                    });
                                    setTimeout(() => updateState({ priceDetected: false }), 2500);
                                }
                            } catch (err) {
                                console.error('Erro no OCR.Space:', err.message, 'Resposta:', err.response?.data);
                                updateState({
                                    ocrResults: {
                                        ocrspace: {
                                            result: {
                                                error: `Erro no OCR.Space: ${err.message}. Verifique a resposta da API no console.`,
                                                rawText: '',
                                                product: bancoDeDados[0].PRODUTO,
                                                volume: bancoDeDados[0].ML,
                                                price: 'R$ 0,00',
                                                id: bancoDeDados[0].id,
                                                confidence: 0,
                                                emoji: 'üòû',
                                                label: 'Ruim',
                                                words: []
                                            }
                                        }
                                    },
                                    newPrice: '0,00',
                                    confidenceData: { confidence: 0, emoji: 'üòû', label: 'Ruim' },
                                    loading: false
                                });
                            }
                        });
                    };
                    reader.onerror = () => updateState({ error: 'Erro ao ler imagem', loading: false });
                } catch (err) {
                    updateState({ error: `Erro ao processar imagem: ${err.message}`, loading: false });
                }
            };

            const handlePriceChange = () => {
                if (!state.newPrice || !state.ocrResults.ocrspace) return;
                const isCervProduct = state.ocrResults.ocrspace.result.product.includes('CERV') || state.ocrResults.ocrspace.result.product.includes('CERVEJA');
                const { price: validatedPrice, confidence, emoji, label } = validatePrice(state.newPrice, isCervProduct, state.ocrResults.ocrspace.result.rawText);
                if (validatedPrice) {
                    updateState({
                        ocrResults: {
                            ocrspace: {
                                result: { ...state.ocrResults.ocrspace.result, price: `R$ ${validatedPrice}`, confidence, emoji, label }
                            }
                        },
                        confidenceData: { confidence, emoji, label },
                        priceDetected: true,
                        editPrice: false
                    });
                    confetti({ 
                        particleCount: 250, 
                        spread: 100, 
                        origin: { y: 0.6 },
                        colors: ['#3b82f6', '#a855f7', '#ffffff'],
                        ticks: 350
                    });
                    setTimeout(() => updateState({ priceDetected: false }), 2500);
                }
            };

            const handleSubmit = async (result) => {
                if (!result?.id || !result?.price || result.price === 'R$ 0,00') return;
                updateState({ loading: true, error: null });
                try {
                    await retryOperation(() =>
                        axios.patch(
                            `https://api.baserow.io/api/database/rows/table/322640/${result.id}/?user_field_names=true`,
                            { "PRE√áO": result.price.replace('R$ ', '').replace(',', '.') },
                            { headers: { Authorization: "Token UkqZsuMMnwE59fMqs8OwXX60SASP7FOd", "Content-Type": "application/json" }, timeout: 15000 }
                        )
                    );
                    updateState({ 
                        success: true,
                        successMessage: `PRODUTO ${result.product} FOI ENVIADO COM SUCESSO PARA BANCO DE DADOS NO VALOR DE ${result.price}`
                    });
                    confetti({ 
                        particleCount: 400, 
                        spread: 120, 
                        origin: { y: 0.5 }, 
                        colors: ['#22c55e', '#10b981', '#ffffff'],
                        ticks: 600
                    });
                    setTimeout(() => updateState({ success: false, successMessage: '' }), 6500);
                } catch (err) {
                    const errorMessage = err.response?.status === 401
                        ? 'Erro de autentica√ß√£o: Token inv√°lido ou expirado. Gere um novo token no Baserow e atualize o c√≥digo.'
                        : `Erro ao enviar pre√ßo: ${err.response?.data?.detail || err.message}`;
                    updateState({ error: errorMessage, success: false });
                    console.error('Detalhes do erro:', err.response?.data || err.message);
                } finally {
                    updateState({ loading: false });
                }
            };

            return (
                <div className="w-full max-w-[440px] mx-auto p-6 flex flex-col gap-5">
                    <header className="header text-center animate-[fadeIn_0.8s_ease-out]">
                        <h1 className="text-3xl font-bold text-white flex items-center justify-center" style={{ fontFamily: 'Orbitron, sans-serif' }}>
                            <svg className="icon mr-3" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                            </svg>
                            OCR Cordeiro
                        </h1>
                    </header>

                    <main className="p-6 flex flex-col gap-6">
                        {state.loading && (
                            <div className="flex flex-col items-center gap-4 animate-[fadeIn_0.8s_ease-out]">
                                <div className="animate-spin rounded-full h-16 w-16 border-t-4 border-purple-400"></div>
                                <div className="progress-bar w-full">
                                    <div className="progress-fill" style={{ width: `${state.progress}%` }}></div>
                                </div>
                            </div>
                        )}

                        {state.error && (
                            <div className="warning-modal text-white flex items-center justify-center gap-3 animate-[fadeIn_0.8s_ease-out]">
                                <svg className="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg>
                                {state.error}
                            </div>
                        )}

                        {state.success && (
                            <div className="success-overlay">
                                <svg className="checkmark" viewBox="0 0 52 52">
                                    <circle className="checkmark__circle" cx="26" cy="26" r="25" fill="none" />
                                    <path className="checkmark__check" fill="none" d="M14.1 27.2l7.1 7.2 16.7-16.8" />
                                </svg>
                                <h2 className="text-white">SUCESSO!</h2>
                                <p className="text-white">{state.successMessage}</p>
                            </div>
                        )}

                        {state.imageUrl ? (
                            <div className="image-container">
                                <img src={state.imageUrl} alt="Produto" ref={imageRef} />
                                {state.loading && <div className="scanning-overlay"></div>}
                            </div>
                        ) : (
                            <div className="bg-gray-900/50 p-4 rounded text-center animate-[fadeIn_0.8s_ease-out]">Sem imagem</div>
                        )}

                        {state.ocrResults.ocrspace?.result && (
                            <div className="bg-gray-900/50 p-6 rounded flex flex-col gap-5 animate-[fadeIn_0.8s_ease-out]">
                                {state.ocrResults.ocrspace.result.error ? (
                                    <div className="text-red-300">{state.ocrResults.ocrspace.result.error}</div>
                                ) : (
                                    <>
                                        <p className="product-label flex items-center gap-2">
                                            <svg className="icon text-purple-300" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z" />
                                            </svg>
                                            <strong className="text-purple-300 font-medium">Produto:</strong> 
                                            <span className="animate-[glow_2s_infinite_ease-in-out]">{state.ocrResults.ocrspace.result.product}</span>
                                        </p>
                                        <p className="flex items-center gap-2">
                                            <svg className="icon text-purple-300" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                            </svg>
                                            <strong className="text-purple-300 font-medium">Volume:</strong> 
                                            <span className="animate-[glow_2s_infinite_ease-in-out]">{state.ocrResults.ocrspace.result.volume ? formatVolume(state.ocrResults.ocrspace.result.volume) : 'N/A'}</span>
                                        </p>
                                        <div className="price-label flex items-center gap-4">
                                            <div className="flex items-center gap-2">
                                                <svg className="icon text-purple-333" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                                </svg>
                                                <strong className="text-purple-300 font-medium">Pre√ßo:</strong>
                                            </div>
                                            {state.editPrice ? (
                                                <div className="flex gap-3">
                                                    <input
                                                        type="text"
                                                        value={state.newPrice}
                                                        onChange={(e) => updateState({ newPrice: e.target.value })}
                                                        className="text-white px-4 py-2 rounded text-sm w-28"
                                                        placeholder="0,00"
                                                    />
                                                    <button onClick={handlePriceChange} className="neon-button text-white px-4 py-2 rounded text-sm">OK</button>
                                                </div>
                                            ) : (
                                                <div className="flex gap-4 items-center">
                                                    <span className="text-xl font-medium animate-[glow_2s_infinite_ease-in-out]">{state.ocrResults.ocrspace.result.price}</span>
                                                    <button onClick={() => updateState({ editPrice: true })} className="text-purple-400 text-sm hover:underline">Editar</button>
                                                </div>
                                            )}
                                        </div>
                                        <ConfidenceBar {...state.confidenceData} />
                                    </>
                                )}
                            </div>
                        )}

                        {state.ocrResults.ocrspace?.result && !state.ocrResults.ocrspace.result.error && (
                            <button
                                onClick={() => handleSubmit(state.ocrResults.ocrspace.result)}
                                className="neon-button text-white flex items-center justify-center"
                                disabled={state.loading || !state.ocrResults.ocrspace?.result?.price || state.ocrResults.ocrspace.result.price === 'R$ 0,00'}
                            >
                                <svg className="icon mr-3" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg>
                                Enviar Pre√ßo
                            </button>
                        )}
                    </main>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
