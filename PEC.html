<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCR Cordeiro</title>
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.7.7/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.25.6/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vanilla-tilt@1.7.2/dist/vanilla-tilt.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://cdn.tailwindcss.com" rel="stylesheet">
    <style>
        :root {
            --bg-color: #F7FAFC;
            --text-color: #1A202C;
            --card-bg: rgba(255, 255, 255, 0.95);
            --button-bg: #1E90FF;
            --button-text: #FFFFFF;
            --accent: #B3E5FC;
            --glow: rgba(30, 144, 255, 0.7);
            --highlight: #FFD700;
            --holo-gradient: linear-gradient(135deg, rgba(30, 144, 255, 0.3), rgba(255, 215, 0, 0.3));
        }

        body {
            background: var(--bg-color);
            color: var(--text-color);
            font-family: 'Roboto', sans-serif;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            overflow-x: hidden;
            letter-spacing: 0.02em;
        }

        canvas#particle-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        .container {
            max-width: 380px;
            width: 100%;
            padding: 1.5rem;
            background: var(--card-bg);
            border-radius: 16px;
            box-shadow: 0 10px 30px var(--glow);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.5s ease;
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .image-container {
            position: relative;
            height: 180px;
            overflow: hidden;
            border-radius: 16px;
            box-shadow: 0 8px 24px var(--glow), 0 4px 12px rgba(0, 0, 0, 0.2);
            background: radial-gradient(circle, var(--accent) 10%, transparent 70%);
            border: 3px solid transparent;
            background-clip: padding-box;
            animation: neonPulse 2.5s infinite ease-in-out;
            transition: transform 0.4s ease, box-shadow 0.4s ease;
        }

        .image-container:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 12px 40px var(--glow), 0 6px 20px rgba(0, 0, 0, 0.3);
            animation: neonBurst 0.5s ease-in-out;
        }

        @keyframes neonPulse {
            0%, 100% { border-color: var(--holo-gradient); box-shadow: 0 0 15px var(--glow); }
            50% { border-color: var(--highlight); box-shadow: 0 0 25px var(--glow); }
        }

        @keyframes neonBurst {
            0% { box-shadow: 0 0 15px var(--glow); }
            50% { box-shadow: 0 0 40px var(--glow), 0 0 60px var(--highlight); }
            100% { box-shadow: 0 0 15px var(--glow); }
        }

        .image-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: center;
            filter: brightness(1.05) contrast(1.1) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
            transition: filter 0.5s ease;
            animation: shimmer 4s infinite linear;
            position: relative;
            z-index: 1;
        }

        @keyframes shimmer {
            0% { filter: brightness(1.05) contrast(1.1); }
            50% { filter: brightness(1.15) contrast(1.2); }
            100% { filter: brightness(1.05) contrast(1.1); }
        }

        .image-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 50%;
            height: 100%;
            background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmerOverlay 3s infinite linear;
            z-index: 2;
        }

        @keyframes shimmerOverlay {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .scanning-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, transparent, var(--highlight) 50%, transparent);
            animation: scanWave 1.5s infinite linear;
            z-index: 3;
        }

        @keyframes scanWave {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }

        .neon-button {
            background: var(--button-bg);
            color: var(--button-text);
            padding: 12px 28px;
            border-radius: 10px;
            font-weight: 500;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px var(--glow);
            border: 1px solid rgba(255, 255, 255, 0.3);
            animation: pulse 2s infinite;
        }

        .neon-button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 25px var(--glow);
        }

        .neon-button:disabled {
            background: #4B5563;
            box-shadow: none;
            cursor: not-allowed;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 15px var(--glow); }
            50% { box-shadow: 0 0 30px var(--glow); }
            100% { box-shadow: 0 0 15px var(--glow); }
        }

        .success-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #10B981, #047857);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            animation: popIn 0.8s ease-out, fadeOut 0.8s ease-out 4.5s forwards;
            z-index: 1000;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .success-overlay h2 {
            font-size: 2rem;
            font-weight: 700;
            text-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
            animation: waveText 0.9s ease-out;
        }

        .success-overlay p {
            font-size: 1rem;
            margin-top: 1rem;
            max-width: 85%;
            text-align: center;
            animation: waveText 0.9s ease-out 0.3s;
        }

        .checkmark {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            stroke-width: 2.5;
            stroke: #fff;
            animation: fill 0.5s ease-in-out 0.5s forwards, scale 0.4s ease-in-out 1s both;
        }

        .checkmark__circle {
            stroke-dasharray: 166;
            stroke-dashoffset: 166;
            stroke-width: 2.5;
            stroke: #22C55E;
            fill: none;
            animation: stroke 0.7s cubic-bezier(0.65, 0, 0.45, 1) forwards;
        }

        .checkmark__check {
            transform-origin: 50% 50%;
            stroke-dasharray: 48;
            stroke-dashoffset: 48;
            animation: stroke 0.4s cubic-bezier(0.65, 0, 0.45, 1) 0.8s forwards;
        }

        @keyframes stroke {
            100% { stroke-dashoffset: 0; }
        }

        @keyframes scale {
            0%, 100% { transform: none; }
            50% { transform: scale3d(1.3, 1.3, 1); }
        }

        @keyframes fill {
            100% { box-shadow: inset 0px 0px 0px 50px #22C55E; }
        }

        @keyframes popIn {
            0% { transform: scale(0.6); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes waveText {
            0% { transform: translateY(20px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        .progress-bar {
            height: 8px;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 6px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--highlight), var(--button-bg));
            transition: width 0.4s ease;
        }

        .confidence-bar {
            height: 10px;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 6px;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(to right, #EF4444, #FACC15, #22C55E);
            transition: width 0.4s ease;
        }

        .confidence-label {
            font-size: 0.85rem;
            text-align: center;
            margin-top: 8px;
            font-weight: 400;
        }

        .warning-modal {
            background: rgba(239, 68, 68, 0.95);
            border-radius: 10px;
            padding: 12px;
            text-align: center;
            box-shadow: 0 6px 15px var(--glow);
            backdrop-filter: blur(5px);
        }

        .text-bbox-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .header {
            padding: 1rem;
            text-align: center;
        }

        .product-label, .price-label {
            animation: slideIn 0.7s ease-out;
        }

        .beer-image-container {
            width: 140px;
            height: 140px;
            position: relative;
            margin: 0 auto;
            border-radius: 16px;
            overflow: hidden;
            background: radial-gradient(circle, var(--accent) 10%, transparent 70%);
            border: 3px solid transparent;
            background-clip: padding-box;
            box-shadow: 0 6px 20px var(--glow);
            animation: neonPulse 2.5s infinite ease-in-out, rotateAura 8s infinite linear;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .beer-image-container:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 30px var(--glow);
            animation: neonBurst 0.5s ease-in-out;
        }

        .beer-image-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: center;
            filter: brightness(1.05) contrast(1.1) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
            transition: filter 0.3s ease, transform 0.5s ease;
            animation: popInImage 0.8s ease-out;
        }

        @keyframes popInImage {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes rotateAura {
            0% { border-color: var(--holo-gradient); }
            50% { border-color: var(--highlight); }
            100% { border-color: var(--holo-gradient); }
        }

        .product-description {
            font-size: 0.8rem;
            color: var(--text-color);
            opacity: 0.85;
            text-align: center;
            margin-top: 10px;
        }

        .separator {
            border: 0;
            height: 1.5px;
            background: linear-gradient(to right, transparent, var(--highlight), transparent);
            margin: 10px 0;
        }

        @keyframes slideIn {
            0% { opacity: 0; transform: translateX(-15px); }
            100% { opacity: 1; transform: translateX(0); }
        }

        @media (max-width: 640px) {
            .container {
                padding: 1.2rem;
            }
            .image-container {
                height: 160px;
            }
            .neon-button {
                padding: 10px 24px;
                font-size: 0.9rem;
            }
            .success-overlay h2 {
                font-size: 1.8rem;
            }
            .success-overlay p {
                font-size: 0.95rem;
            }
            .checkmark {
                width: 80px;
                height: 80px;
            }
            .beer-image-container {
                width: 120px;
                height: 120px;
            }
            .product-description {
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="particle-bg"></canvas>
    <div id="root"></div>
    <script>
        // Particle background with orbiting effect
        const canvas = document.getElementById('particle-bg');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const particles = [];
        for (let i = 0; i < 80; i++) {
            particles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                radius: Math.random() * 1.5 + 0.8,
                speed: Math.random() * 0.4 + 0.2,
                angle: Math.random() * Math.PI * 2
            });
        }

        ctx.fillStyle = 'rgba(30, 144, 255, 0.6)';
        function animateParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach(p => {
                p.angle += p.speed * 0.01;
                p.x += Math.cos(p.angle) * p.speed;
                p.y += Math.sin(p.angle) * p.speed;
                if (p.x < 0) p.x += canvas.width;
                if (p.x > canvas.width) p.x -= canvas.width;
                if (p.y < 0) p.y += canvas.height;
                if (p.y > canvas.height) p.y -= canvas.height;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            requestAnimationFrame(animateParticles);
        }
        animateParticles();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Initialize Tilt.js
        document.addEventListener('DOMContentLoaded', () => {
            VanillaTilt.init(document.querySelectorAll('.image-container, .beer-image-container, .container'), {
                max: 6,
                speed: 800,
                glare: true,
                'max-glare': 0.3
            });
        });

        window.addEventListener('error', (event) => {
            console.error('Erro global:', event.message, event.filename, event.lineno, event.colno, event.error?.stack || 'No stack trace');
            document.getElementById('root').innerHTML = `
                <div className="bg-red-900/50 text-red-300 p-4 rounded text-center">
                    Erro crítico: ${event.message}. Verifique o console.
                </div>
            `;
        });

        function preprocessImage(base64Image, callback) {
            const img = new Image();
            img.src = `data:image/jpeg;base64,${base64Image}`;
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                callback(canvas.toDataURL('image/jpeg', 0.9).split(',')[1]);
            };
            img.onerror = () => callback(null);
        }

        function drawTextBoundingBoxes(imageElement, words) {
            const existingCanvas = imageElement.parentElement.querySelector('.text-bbox-canvas');
            if (existingCanvas) existingCanvas.remove();

            const canvas = document.createElement('canvas');
            canvas.className = 'text-bbox-canvas';
            const ctx = canvas.getContext('2d');
            const container = imageElement.parentElement;

            const rect = imageElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;

            const scaleX = rect.width / imageElement.naturalWidth;
            const scaleY = rect.height / imageElement.naturalHeight;

            container.style.position = 'relative';
            container.appendChild(canvas);

            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2.5;
            ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
            ctx.shadowBlur = 8;

            const volumeRegex = /(\d+)(ML|L|LT|LTR|LTRO|LITRO)/i;
            const processedWords = [];

            words.forEach(word => {
                const volumeMatch = word.text.match(volumeRegex);
                if (volumeMatch) {
                    processedWords.push({
                        text: word.text,
                        confidence: word.confidence || 50,
                        bbox: word.bbox,
                        isVolume: true
                    });
                } else {
                    const concatenatedMatch = word.text.match(/^(.*?[A-Z])(\d+)(ML|L|LT|LTR|LTRO|LITRO)$/i);
                    if (concatenatedMatch) {
                        const brandPart = concatenatedMatch[1];
                        const volumePart = `${concatenatedMatch[2]}${concatenatedMatch[3]}`;
                        const brandWidth = (brandPart.length / word.text.length) * (word.bbox.x1 - word.bbox.x0);
                        const volumeWidth = (volumePart.length / word.text.length) * (word.bbox.x1 - word.bbox.x0);

                        processedWords.push({
                            text: brandPart,
                            confidence: word.confidence || 50,
                            bbox: {
                                x0: word.bbox.x0,
                                y0: word.bbox.y0,
                                x1: word.bbox.x0 + brandWidth,
                                y1: word.bbox.y1
                            },
                            isVolume: false
                        });
                        processedWords.push({
                            text: volumePart,
                            confidence: word.confidence || 50,
                            bbox: {
                                x0: word.bbox.x0 + brandWidth,
                                y0: word.bbox.y0,
                                x1: word.bbox.x1,
                                y1: word.bbox.y1
                            },
                            isVolume: true
                        });
                    } else {
                        processedWords.push({
                            text: word.text,
                            confidence: word.confidence || 50,
                            bbox: word.bbox,
                            isVolume: knownVolumes.includes(parseInt(word.text))
                        });
                    }
                }
            });

            processedWords.forEach(word => {
                if (word.bbox && word.confidence >= 50) {
                    const isPrice = word.text.match(/(R\$)?\s*\d+[,.]\d{2}/) || word.text.match(/\d+[,.]\d{2}/);
                    ctx.strokeStyle = word.isVolume || isPrice ? '#22C55E' : 'red';
                    ctx.shadowColor = word.isVolume || isPrice ? 'rgba(34, 197, 94, 0.6)' : 'rgba(255, 0, 0, 0.5)';
                    ctx.lineWidth = word.isVolume || isPrice ? 3 : 2.5;

                    ctx.beginPath();
                    ctx.rect(
                        word.bbox.x0 * scaleX,
                        word.bbox.y0 * scaleY,
                        (word.bbox.x1 - word.bbox.x0) * scaleX,
                        (word.bbox.y1 - word.bbox.y0) * scaleY
                    );
                    ctx.stroke();

                    if (word.isVolume || isPrice) {
                        ctx.beginPath();
                        ctx.strokeStyle = 'rgba(34, 197, 94, 0.4)';
                        ctx.lineWidth = 6;
                        ctx.rect(
                            word.bbox.x0 * scaleX - 2,
                            word.bbox.y0 * scaleY - 2,
                            (word.bbox.x1 - word.bbox.x0) * scaleX + 4,
                            (word.bbox.y1 - word.bbox.y0) * scaleY + 4
                        );
                        ctx.stroke();

                        const rectCenterX = (word.bbox.x0 + (word.bbox.x1 - word.bbox.x0) / 2) * scaleX;
                        const rectCenterY = (word.bbox.y0 + (word.bbox.y1 - word.bbox.y0) / 2) * scaleY;
                        confetti({
                            particleCount: 30,
                            spread: 40,
                            origin: {
                                x: (rectCenterX + container.getBoundingClientRect().left) / window.innerWidth,
                                y: (rectCenterY + container.getBoundingClientRect().top) / window.innerHeight
                            },
                            colors: ['#1E90FF', '#22C55E'],
                            ticks: 100
                        });
                    }
                }
            });
        }
    </script>
    <script type="text/babel">
        const bancoDeDados = [
            { id: 3, PRODUTO: 'CERV LAGER HEINEKEN LN 6X330ml', ML: 330, brand: 'HEINEKEN' },
            { id: 4, PRODUTO: 'CERV STELLA ARTOIS LN 6X330ml', ML: 330, brand: 'STELLA ARTOIS' },
            { id: 5, PRODUTO: 'CERV LAGER CORONA LN 6X330ml', ML: 330, brand: 'CORONA' },
            { id: 6, PRODUTO: 'CERV LAGER BUDWEISER LN 6X330ml', ML: 330, brand: 'BUDWEISER' },
            { id: 7, PRODUTO: 'CERV HEINEKEN ZERO ALC LN 6X330ml', ML: 330, brand: 'HEINEKEN' },
            { id: 8, PRODUTO: 'CERV P MALTE SPATEM LN 6X355ml', ML: 355, brand: 'SPATEM' },
            { id: 9, PRODUTO: 'CERV BRAHMA ZERO ÁLCOOL 12X350ml', ML: 350, brand: 'BRAHMA' },
            { id: 10, PRODUTO: 'CERV HEINEKEN ZERO ÁLCOOL 12X350ml', ML: 350, brand: 'HEINEKEN' },
            { id: 11, PRODUTO: 'CERV EISENBAHN 12X473ml', ML: 473, brand: 'EISENBAHN' },
            { id: 12, PRODUTO: 'CERVEJA LAGER AMSTEL 12X473ml', ML: 473, brand: 'AMSTEL' },
            { id: 13, PRODUTO: 'CERV HEINEKEN LT 12X473ml', ML: 473, brand: 'HEINEKEN' },
            { id: 14, PRODUTO: 'CERVEJA KAISER 12X473ml', ML: 473, brand: 'KAISER' },
            { id: 15, PRODUTO: 'CERV PILSEN ANTARTICA 12X473ml', ML: 473, brand: 'ANTARCTICA' },
            { id: 16, PRODUTO: 'CERV ANTARCTICA ORIGINAL 12X473ml', ML: 473, brand: 'ANTARCTICA' },
            { id: 17, PRODUTO: 'CERVEJA BRAHMA 12X473ml', ML: 473, brand: 'BRAHMA' },
            { id: 18, PRODUTO: 'CERVEJA STELLA ARTOIS 12X473ml', ML: 473, brand: 'STELLA ARTOIS' },
            { id: 19, PRODUTO: 'CERV P MALTE BOHEMIA 473ml', ML: 473, brand: 'BOHEMIA' },
            { id: 20, PRODUTO: 'CERV P MALTE SPATEM LT 12X473ml', ML: 473, brand: 'SPATEM' },
            { id: 21, PRODUTO: 'CERV ANTARCTICA SUB ZERO 473ml', ML: 473, brand: 'ANTARCTICA' },
            { id: 22, PRODUTO: 'LEITE ITAMBÊ INTEGRAL 12X1L', ML: 1, brand: 'ITAMBÊ' },
            { id: 23, PRODUTO: 'LEITE ITAMBÊ DESNATADO 12X1L', ML: 1, brand: 'ITAMBÊ' },
            { id: 24, PRODUTO: 'LEITE ITAMBÊ SEMIDESNATADO 12X1L', ML: 1, brand: 'ITAMBÊ' },
            { id: 25, PRODUTO: 'LEITE PORTO ALEGRE INTEGRAL 12X1L', ML: 1, brand: 'PORTO ALEGRE' },
            { id: 26, PRODUTO: 'LEITE QUATA INTEGRAL 12X1L', ML: 1, brand: 'QUATA' },
            { id: 27, PRODUTO: 'LEITE PIRACANJUBA INTEGRAL 12X1L', ML: 1, brand: 'PIRACANJUBA' },
            { id: 28, PRODUTO: 'ÁGUA IGARAPE SEM GÁS 12X500ml', ML: 500, brand: 'IGARAPE' },
            { id: 29, PRODUTO: 'ÁGUA IGARAPÉ COM GÁS 12X500ml', ML: 500, brand: 'IGARAPE' },
            { id: 30, PRODUTO: 'REFRI COCA COLA MINI PET 12X200ml', ML: 200, brand: 'COCA COLA' },
            { id: 31, PRODUTO: 'REFRI SUKITA LARANJA PET 12X200ml', ML: 200, brand: 'SUKITA' },
            { id: 32, PRODUTO: 'REFRI SODA LIMONADA PET 12X200ml', ML: 200, brand: 'SODA' },
            { id: 33, PRODUTO: 'REFRI GUARANÁ ANTARTICA PET 12X200ml', ML: 200, brand: 'GUARANÁ ANTARTICA' },
            { id: 34, PRODUTO: 'REFRI GUARANÁ ZERO PET 12X200ml', ML: 200, brand: 'GUARANÁ ANTARTICA' },
            { id: 35, PRODUTO: 'REFRI PEPSI PET 12X200ml', ML: 200, brand: 'PEPSI' },
            { id: 36, PRODUTO: 'ÓLEO DE SOJA VELEIRO 6X900ml', ML: 900, brand: 'VELEIRO' },
            { id: 37, PRODUTO: 'ÓLEO DE SOJA LIZA 6X900ml', ML: 900, brand: 'LIZA' },
            { id: 38, PRODUTO: 'CERV MALZBIER BRAHMA 6X355ml', ML: 355, brand: 'BRAHMA' },
            { id: 39, PRODUTO: 'CERV PILSEN IMPERIO 12X473ml', ML: 473, brand: 'IMPERIO' },
            { id: 40, PRODUTO: 'CERV PILSEN BUDWEISER 12X473ml', ML: 473, brand: 'BUDWEISER' },
            { id: 67, PRODUTO: 'LEITE INTEGRAL ITA 12X1L', ML: 1, brand: 'ITA' },
            { id: 68, PRODUTO: 'LEITE INTEGRAL ITALAC 12X1L', ML: 1, brand: 'ITALAC' },
            { id: 69, PRODUTO: 'AGUA MIN GRAO MOGOL 12X500ml', ML: 500, brand: 'GRAO MOGOL' },
            { id: 70, PRODUTO: 'CERV P MALTE SPATEM LN 6X355ml', ML: 355, brand: 'SPATEM' },
            { id: 71, PRODUTO: 'CERV LAGER HEINEKEN LN 6X355ml', ML: 355, brand: 'HEINEKEN' },
            { id: 72, PRODUTO: 'CERV PILSEN BRUDER BX GASTRO 12X473ml', ML: 473, brand: 'BRUDER' },
            { id: 73, PRODUTO: 'CERV PILSEN LAUT 12X473ml', ML: 473, brand: 'LAUT' },
            { id: 74, PRODUTO: 'CERV P MALTE PETRA 12X473ml', ML: 473, brand: 'PETRA' },
            { id: 75, PRODUTO: 'CERV PILSEN ITAIPAVA LT 12X473ml', ML: 473, brand: 'ITAIPAVA' },
            { id: 76, PRODUTO: 'CERV PILSEN SKOL LT 12X473ml', ML: 473, brand: 'SKOL' },
            { id: 100, PRODUTO: 'CERV LAGER CORONA LN 6X330ml', ML: 330, brand: 'CORONA' },
            { id: 133, PRODUTO: 'CERV LAGER BUDWEISER LN 6X330ml', ML: 330, brand: 'BUDWEISER' },
            { id: 167, PRODUTO: 'CERV PILSEN LAUT 12X473ml', ML: 473, brand: 'LAUT' },
            { id: 199, PRODUTO: 'REFRI CAÇULINHA SODA 12X200ml', ML: 200, brand: 'CAÇULINHA' },
            { id: 232, PRODUTO: 'CERV LAGER HEINEKEN LN 6X330ml', ML: 330, brand: 'HEINEKEN' },
            { id: 233, PRODUTO: 'CERV LAGER HEINEKEN LN 6X330ml', ML: 330, brand: 'HEINEKEN' },
            { id: 265, PRODUTO: 'CERVEJA KAISER 12X473ml', ML: 473, brand: 'KAISER' },
            { id: 266, PRODUTO: 'CERV MALZIBIER CARACU 12X350ml', ML: 350, brand: 'CARACU' },
            { id: 298, PRODUTO: 'LEITE INTEGRAL CEMIL 12X1L', ML: 1, brand: 'CEMIL' },
            { id: 331, PRODUTO: 'CERV ZERO ALC BUDWEISER LN 6x330ml', ML: 330, brand: 'BUDWEISER' },
            { id: 364, PRODUTO: 'CERV AMERICA IPA EISENBAHN LN 6X355ml', ML: 355, brand: 'EISENBAHN' },
            { id: 65, PRODUTO: 'CERV PALE ALE EISENBAHN LN 6X355ml', ML: 355, brand: 'EISENBAHN' },
            { id: 366, PRODUTO: 'CERV PILSEN BRAHMA LN 6X355ml', ML: 355, brand: 'BRAHMA' },
            { id: 367, PRODUTO: 'CERV UTRA AMSTEL LN 6X275ml', ML: 275, brand: 'AMSTEL' },
            { id: 368, PRODUTO: 'FANTA LARANJA ZERO 12x2l', ML: 2, brand: 'FANTA' },
            { id: 397, PRODUTO: 'COQ COROTE LIMÃO 12X500ml', ML: 500, brand: 'COROTE' }
        ];

        const keywords = [
            'CERV', 'CERVEJA', 'LAGER', 'PILSEN', 'ZERO', 'ALC', 'ÁLCOOL', 'MALTE', 'ORIGINAL', 'SUB', 'LN', 'LONG NECK',
            'LEITE', 'INTEGRAL', 'DESNATADO', 'SEMIDESNATADO', 'AGUA', 'GAS', 'REFRI', 'SODA',
            'LIMONADA', 'GUARANA', 'OLEO', 'SOJA', 'MALZBIER', 'IPA', 'PALE', 'ALE', 'UTRA'
        ];

        const brandPrefixes = [
            { prefix: 'HEI', brand: 'HEINEKEN', score: 100 },
            { prefix: 'STE', brand: 'STELLA ARTOIS', score: 100 },
            { prefix: 'COR', brand: 'CORONA', score: 100 },
            { prefix: 'BUD', brand: 'BUDWEISER', score: 100 },
            { prefix: 'SPA', brand: 'SPATEM', score: 100 },
            { prefix: 'BRA', brand: 'BRAHMA', score: 100 },
            { prefix: 'EIS', brand: 'EISENBAHN', score: 100 },
            { prefix: 'AMS', brand: 'AMSTEL', score: 100 },
            { prefix: 'KAI', brand: 'KAISER', score: 100 },
            { prefix: 'ANT', brand: 'ANTARCTICA', score: 100 },
            { prefix: 'BOH', brand: 'BOHEMIA', score: 100 },
            { prefix: 'ITA', brand: 'ITAIPAVA', score: 100 },
            { prefix: 'SKO', brand: 'SKOL', score: 100 },
            { prefix: 'PET', brand: 'PETRA', score: 100 },
            { prefix: 'LAU', brand: 'LAUT', score: 100 },
            { prefix: 'BRU', brand: 'BRUDER', score: 100 },
            { prefix: 'ITAM', brand: 'ITAMBÊ', score: 100 },
            { prefix: 'PORTO', brand: 'PORTO ALEGRE', score: 100 },
            { prefix: 'QUA', brand: 'QUATA', score: 100 },
            { prefix: 'PIR', brand: 'PIRACANJUBA', score: 100 },
            { prefix: 'IGA', brand: 'IGARAPE', score: 100 },
            { prefix: 'COC', brand: 'COCA COLA', score: 100 },
            { prefix: 'SUK', brand: 'SUKITA', score: 100 },
            { prefix: 'GUA', brand: 'GUARANÁ ANTARTICA', score: 100 },
            { prefix: 'PEP', brand: 'PEPSI', score: 100 },
            { prefix: 'VELE', brand: 'VELEIRO', score: 100 },
            { prefix: 'LIZ', brand: 'LIZA', score: 100 },
            { prefix: 'CAR', brand: 'CARACU', score: 100 },
            { prefix: 'CEM', brand: 'CEMIL', score: 100 },
            { prefix: 'FAN', brand: 'FANTA', score: 100 },
            { prefix: 'COQ', brand: 'COROTE', score: 100 }
        ];

        const knownVolumes = [473, 330, 350, 500, 200, 900, 1, 355, 275, 2];

        function formatVolume(ml) {
            if (ml <= 2) {
                return `${ml}L`;
            }
            return `${ml}ml`;
        }

        function calculatePriceConfidence(price, rawText) {
            let score = 0;
            if (/R\$\s*\d+[,.]\d{2}/.test(rawText)) score += 50;
            else if (/\d+[,.]\d{2}/.test(price)) score += 30;
            else if (/\d+[,.]\d/.test(price)) score += 20;
            else if (/^\d+$/.test(price) && !knownVolumes.includes(parseInt(price))) score += 10;
            if (/(PREÇO|VALOR|R\$)/i.test(rawText)) score += 15;
            const confidence = Math.min(100, score);
            const emoji = confidence >= 95 ? '😎' : confidence >= 85 ? '😊' : confidence >= 50 ? '😐' : '😞';
            const label = confidence >= 95 ? 'Muito Bom' : confidence >= 85 ? 'Bom' : confidence >= 50 ? 'Médio' : 'Ruim';
            console.log('Price Confidence:', { confidence, emoji, label });
            return { confidence, emoji, label };
        }

        function calculateProductConfidence(normalizedText, matchedProduct, volumeMatch) {
            let score = 0;
            const normalizedProduct = normalizeText(matchedProduct.PRODUTO);
            const productWords = normalizedProduct.split(' ');
            const textWords = normalizedText.split(' ');
            const volume = volumeMatch ? parseInt(volumeMatch[1]) : null;
            const isLiter = volumeMatch && /L|LT|LTR|LTRO|LITRO/i.test(volumeMatch[2]);

            if (normalizedText.includes(normalizeText(matchedProduct.brand))) {
                score += 200;
            } else {
                brandPrefixes.forEach(({ prefix, brand }) => {
                    if (normalizedText.includes(prefix) && normalizeText(matchedProduct.brand).includes(brand)) {
                        score += 150;
                    }
                });
            }

            const descriptors = ['ZERO', 'ALC', 'ÁLCOOL', 'LN', 'LONG NECK', 'ORIGINAL', 'PILSEN'];
            descriptors.forEach(desc => {
                if (normalizedText.includes(desc) && normalizedProduct.includes(desc)) {
                    score += desc === 'ORIGINAL' ? 200 : 100;
                } else if (normalizedText.includes(desc) !== normalizedProduct.includes(desc)) {
                    score -= desc === 'ORIGINAL' ? 100 : 50;
                }
            });

            productWords.forEach(word => {
                if (textWords.includes(word)) {
                    score += keywords.includes(word) ? 40 : 15;
                }
            });

            if (volume) {
                if (isLiter && matchedProduct.ML <= 2 && volume === matchedProduct.ML) {
                    score += 150;
                } else if (!isLiter && matchedProduct.ML === volume) {
                    score += 120;
                }
                if (knownVolumes.includes(volume)) score += 30;
            }

            const similarity = productWords.filter(word => textWords.includes(word)).length / productWords.length;
            if (similarity >= 0.9) {
                score += 100;
            } else if (similarity >= 0.7) {
                score += 50;
            } else if (similarity >= 0.5) {
                score += 30;
            }

            const isExactMatch = normalizedText.includes(normalizeText(matchedProduct.brand)) &&
                                 volume === matchedProduct.ML &&
                                 similarity >= 0.9 &&
                                 descriptors.every(desc => normalizedText.includes(desc) === normalizedProduct.includes(desc));

            const confidence = isExactMatch ? 100 : Math.min(100, Math.max(50, Math.round(score / 3)));
            const emoji = confidence === 100 ? '🔥' : confidence >= 95 ? '😎' : confidence >= 85 ? '😊' : confidence >= 50 ? '😐' : '😞';
            const label = confidence === 100 ? 'Perfeito' : confidence >= 95 ? 'Muito Bom' : confidence >= 85 ? 'Bom' : confidence >= 50 ? 'Médio' : 'Ruim';
            console.log('Product Confidence:', { confidence, emoji, label });
            return { confidence, emoji, label };
        }

        function validatePrice(price, isCervProduct, rawText) {
            if (!price || /R\$\s*0,00/i.test(rawText)) {
                return { price: '0,00', confidence: 0, emoji: '😞', label: 'Ruim' };
            }

            let numPrice;
            const volumeLike = ['473', '330', '350', '500', '200', '900', '1', '355', '275', '2'];
            price = price.replace(',', '.').replace(/[^\d.]/g, '');
            if (/^\d+$/.test(price) && volumeLike.includes(price)) {
                price = '0,00';
            } else if (/^\d+[,.]\d{2}$/.test(price)) {
                price = price.replace('.', ',');
            } else if (/^\d+[,.]\d$/.test(price)) {
                price = `${price[0]},${price.slice(2) || '0'}0`;
            } else if (/^\d+$/.test(price)) {
                price = `${price},00`;
            } else {
                price = '0,00';
            }
            numPrice = parseFloat(price.replace(',', '.'));
            if (isNaN(numPrice)) {
                return { price: '0,00', confidence: 0, emoji: '😞', label: 'Ruim' };
            }
            if (isCervProduct && numPrice < 0.20) {
                return { price: '0,00', confidence: 0, emoji: '😞', label: 'Ruim' };
            }
            if (numPrice > 12.00) {
                numPrice = 12.00;
            }
            const finalPrice = numPrice.toFixed(2).replace('.', ',');
            const { confidence, emoji, label } = calculatePriceConfidence(finalPrice, rawText);
            return { price: finalPrice, confidence, emoji, label };
        }

        function correctOcrText(text) {
            if (typeof text !== 'string') {
                console.warn('correctOcrText: Input não é uma string, retornando vazio', text);
                return '';
            }
            const corrections = [
                { wrong: /\b[Ss](?=\d*[,.]\d)/gi, correct: '5' },
                { wrong: /\b[Oo](?=\d*[,.]\d)/gi, correct: '0' },
                { wrong: /\b(RS|RZ|S)\b/gi, correct: 'R$' },
                { wrong: /\b(\d+)[,.](\d{1,2})\b/gi, correct: '$1,$2' },
                { wrong: /\bHE1NEKEN\b/gi, correct: 'HEINEKEN' },
                { wrong: /\bSTEL1A\b/gi, correct: 'STELLA' },
                { wrong: /\bC0R0NA\b/gi, correct: 'CORONA' },
                { wrong: /\bBUDWE1SER\b/gi, correct: 'BUDWEISER' },
                { wrong: /\bSPATEN\b/gi, correct: 'SPATEM' },
                { wrong: /\bBRAMA\b/gi, correct: 'BRAHMA' },
                { wrong: /\bE1SENBAHN\b/gi, correct: 'EISENBAHN' },
                { wrong: /\bAMST3L\b/gi, correct: 'AMSTEL' },
                { wrong: /\bKA1SER\b/gi, correct: 'KAISER' },
                { wrong: /\bANTART1CA\b/gi, correct: 'ANTARCTICA' },
                { wrong: /\bB0HEMIA\b/gi, correct: 'BOHEMIA' },
                { wrong: /\bSK0L\b/gi, correct: 'SKOL' },
                { wrong: /\b1TA1PAVA\b/gi, correct: 'ITAIPAVA' },
                { wrong: /\b(LT|LTR|LTRO)\b/gi, correct: 'LITRO' },
                { wrong: /\bC00\b/gi, correct: 'COQ' },
                { wrong: /\bC0Q\b/gi, correct: 'COQ' },
                { wrong: /\bC0R0TE\b/gi, correct: 'COROTE' },
                { wrong: /\bLIMAO\b/gi, correct: 'LIMÃO' },
                { wrong: /\b0LEO\b/gi, correct: 'ÓLEO' },
                { wrong: /\bORIG\b(?=\s*ANTARCTICA)/gi, correct: 'ORIGINAL' },
                { wrong: /\b(ANTARCTICA)(\d+)(ML|L|LT|LTR|LTRO|LITRO)\b/gi, correct: '$1 $2$3' }
            ];
            let corrected = text;
            corrections.forEach(({ wrong, correct }) => {
                corrected = corrected.replace(wrong, correct);
            });
            return corrected;
        }

        function normalizeText(text) {
            if (typeof text !== 'string') {
                console.warn('normalizeText: Input não é uma string, retornando vazio', text);
                return '';
            }
            return text
                .toUpperCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                .replace(/\s+/g, ' ')
                .replace(/[^A-Z0-9\s]/g, '')
                .trim();
        }

        function findBestMatch(normalizedText, database) {
            const volumeMatch = normalizedText.match(/(\d+)(ML|L|LT|LTR|LTRO|LITRO)/i);
            const volume = volumeMatch ? parseInt(volumeMatch[1]) : null;
            const isLiter = volumeMatch && /L|LT|LTR|LTRO|LITRO/i.test(volumeMatch[2]);
            const textWords = normalizedText.split(' ');
            let bestMatch = null;
            let highestScore = -Infinity;
            let currentDatabase = [...database];
            const penalizedIds = new Set();
            let iteration = 0;

            const isOriginalAntarctica = normalizedText.includes('ORIGINAL') || normalizedText.includes('ORIG');

            while (currentDatabase.length > 0 && iteration < 3) {
                const scores = [];
                let hasPenalty = false;

                currentDatabase.forEach(product => {
                    const normalizedProduct = normalizeText(product.PRODUTO);
                    const productWords = normalizedProduct.split(' ');
                    let score = 0;

                    if (normalizedText.includes(normalizeText(product.brand))) {
                        score += 200;
                    } else {
                        brandPrefixes.forEach(({ prefix, brand }) => {
                            if (normalizedText.includes(prefix) && normalizeText(product.brand).includes(brand)) {
                                score += 150;
                            }
                        });
                    }

                    const descriptors = ['ZERO', 'ALC', 'ÁLCOOL', 'LN', 'LONG NECK', 'ORIGINAL', 'PILSEN'];
                    descriptors.forEach(desc => {
                        if (normalizedText.includes(desc) && normalizedProduct.includes(desc)) {
                            score += desc === 'ORIGINAL' ? 200 : 100;
                        } else if (normalizedText.includes(desc) !== normalizedProduct.includes(desc)) {
                            score -= desc === 'ORIGINAL' ? 100 : 50;
                            penalizedIds.add(product.id);
                            hasPenalty = true;
                        }
                    });

                    if (product.brand === 'ANTARCTICA' && volume === 473) {
                        if (isOriginalAntarctica && product.id === 16) {
                            score += 300;
                        } else if (!isOriginalAntarctica && product.id === 15) {
                            score += 250;
                        } else {
                            score -= 100;
                        }
                    }

                    productWords.forEach(word => {
                        if (textWords.includes(word)) {
                            score += keywords.includes(word) ? 40 : 15;
                        }
                    });

                    if (volume) {
                        if (isLiter && product.ML <= 2 && volume === product.ML) {
                            score += 150;
                        } else if (!isLiter && product.ML === volume) {
                            score += 120;
                        }
                        if (knownVolumes.includes(volume)) score += 30;
                    }

                    const similarity = productWords.filter(word => textWords.includes(word)).length / productWords.length;
                    if (similarity >= 0.9) {
                        score += 100;
                    } else if (similarity >= 0.7) {
                        score += 50;
                    } else if (similarity >= 0.5) {
                        score += 30;
                    }

                    if (normalizedText.includes('ANTARCTICA' + volume) && product.brand === 'ANTARCTICA') {
                        score += 50;
                    }

                    scores.push({ product: product.PRODUTO, id: product.id, score, similarity: similarity.toFixed(2) });
                });

                scores.sort((a, b) => b.score - a.score);
                console.log(`Iteração ${iteration + 1} Scores:`, scores);
                console.log(`Penalizados:`, Array.from(penalizedIds));

                if (scores.length > 0) {
                    bestMatch = currentDatabase.find(p => normalizeText(p.PRODUTO) === normalizeText(scores[0].product));
                    highestScore = scores[0].score;

                    if (highestScore >= 100 && (!hasPenalty || scores[0].score - (scores[1]?.score || 0) >= 5)) {
                        console.log(`Melhor correspondência encontrada na iteração ${iteration + 1}:`, bestMatch);
                        return bestMatch;
                    }
                }

                currentDatabase = currentDatabase.filter(p => !penalizedIds.has(p.id));
                iteration++;
            }

            console.warn('Nenhuma correspondência válida encontrada após todas as iterações. Retornando padrão:', bancoDeDados[0]);
            return bancoDeDados[0];
        }

        async function retryOperation(fn, maxRetries = 2, delay = 300) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    return await fn();
                } catch (err) {
                    console.error(`Tentativa ${attempt} falhou: ${err.message}`);
                    if (attempt === maxRetries) throw err;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        function ConfidenceBar({ confidence, emoji, label }) {
            return (
                <div className="animate-[slideIn_0.7s_ease-out]">
                    <div className="confidence-bar">
                        <div className="confidence-fill" style={{ width: `${confidence}%` }}></div>
                    </div>
                    <div className="confidence-label">{emoji} {label} ({confidence}%)</div>
                </div>
            );
        }

        function App() {
            const [state, setState] = React.useState({
                imageUrl: '',
                ocrResults: {},
                loading: false,
                error: null,
                editPrice: false,
                newPrice: '',
                success: false,
                successMessage: '',
                priceDetected: false,
                progress: 0,
                beerImageUrl: ''
            });
            const imageRef = React.useRef(null);

            const updateState = (updates) => setState(prev => ({ ...prev, ...updates }));

            React.useEffect(() => {
                const fetchImage = async () => {
                    updateState({ loading: true });
                    try {
                        const response = await retryOperation(() =>
                            axios.get(
                                "https://api.baserow.io/api/database/rows/table/587819/2/?user_field_names=true",
                                { headers: { Authorization: "Token UkqZsuMMnwE59fMqs8OwXX60SASP7FOd" } }
                            )
                        );
                        updateState({ imageUrl: response.data.urlimagem });
                    } catch (err) {
                        updateState({ error: `Erro ao buscar imagem: ${err.message}` });
                    } finally {
                        updateState({ loading: false });
                    }
                };
                fetchImage();
            }, []);

            React.useEffect(() => {
                if (state.imageUrl) processImage(state.imageUrl);
            }, [state.imageUrl]);

            React.useEffect(() => {
                if (imageRef.current && state.ocrResults.ocrspace?.result?.words?.length > 0) {
                    drawTextBoundingBoxes(imageRef.current, state.ocrResults.ocrspace.result.words);
                }
            }, [state.ocrResults]);

            React.useEffect(() => {
                if (state.ocrResults.ocrspace?.result?.id) {
                    const fetchBeerImage = async () => {
                        try {
                            const response = await retryOperation(() =>
                                axios.get(
                                    `https://api.baserow.io/api/database/rows/table/322640/${state.ocrResults.ocrspace.result.id}/?user_field_names=true`,
                                    { headers: { Authorization: "Token UkqZsuMMnwE59fMqs8OwXX60SASP7FOd" } }
                                )
                            );
                            updateState({ beerImageUrl: response.data['IMAGEM URL'] || '' });
                            if (response.data['IMAGEM URL']) {
                                confetti({
                                    particleCount: 50,
                                    spread: 60,
                                    origin: { y: 0.3 },
                                    colors: ['#1E90FF', '#FFD700'],
                                    ticks: 150
                                });
                            }
                        } catch (err) {
                            console.error('Erro ao buscar imagem do produto:', err.message);
                            updateState({ beerImageUrl: '' });
                        }
                    };
                    fetchBeerImage();
                }
            }, [state.ocrResults.ocrspace?.result?.id]);

            const processImage = async (url) => {
                updateState({ loading: true, error: null, progress: 0 });
                try {
                    const response = await retryOperation(() =>
                        axios.get(url, { responseType: 'blob', timeout: 15000 })
                    );
                    const reader = new FileReader();
                    reader.readAsDataURL(response.data);
                    reader.onloadend = () => {
                        const base64Image = reader.result.split(',')[1];
                        preprocessImage(base64Image, async (processedImage) => {
                            if (!processedImage) {
                                updateState({ error: 'Erro ao preprocessar imagem', loading: false });
                                return;
                            }
                            try {
                                const formData = new FormData();
                                formData.append('base64Image', `data:image/jpeg;base64,${processedImage}`);
                                formData.append('language', 'por');
                                formData.append('isOverlayRequired', 'true');
                                formData.append('OCREngine', '2');
                                formData.append('scale', 'true');
                                formData.append('detectOrientation', 'true');
                                const ocrSpaceResponse = await retryOperation(() =>
                                    axios.post('https://api.ocr.space/parse/image', formData, {
                                        headers: { 'apikey': 'K86154304788957', 'Content-Type': 'multipart/form-data' },
                                        timeout: 15000
                                    })
                                );
                                updateState({ progress: 100 });
                                const ocrText = ocrSpaceResponse.data?.ParsedResults?.[0]?.ParsedText || '';
                                if (!ocrText && ocrSpaceResponse.data) {
                                    console.warn('OCR.Space retornou resposta inválida:', ocrSpaceResponse.data);
                                }
                                const correctedText = correctOcrText(ocrText);
                                const normalizedText = normalizeText(correctedText);
                                let ocrPrice = correctedText.match(/(R\$)?\s*\d+[,.]\d{2}/)?.[0] || 
                                              correctedText.match(/(R\$)?\s*\d+[,.]\d/)?.[0] || '';
                                ocrPrice = ocrPrice.replace(/R\$/, '').trim();
                                if (!ocrPrice) ocrPrice = '0,00';
                                const volumeMatch = normalizedText.match(/(\d+)(ML|L|LT|LTR|LTRO|LITRO)/i);
                                const matchedProduct = findBestMatch(normalizedText, bancoDeDados);
                                const isCervProduct = normalizedText.includes('CERV') || normalizedText.includes('CERVEJA');
                                const { price: validatedPrice, confidence: priceConfidence, emoji: priceEmoji, label: priceLabel } = validatePrice(ocrPrice, isCervProduct, correctedText);
                                const { confidence: productConfidence, emoji: productEmoji, label: productLabel } = calculateProductConfidence(normalizedText, matchedProduct, volumeMatch);
                                const words = ocrSpaceResponse.data?.ParsedResults?.[0]?.TextOverlay?.Lines?.flatMap(line =>
                                    line.Words.map(word => ({
                                        text: word.WordText,
                                        confidence: word.Confidence || 50,
                                        bbox: {
                                            x0: word.Left,
                                            y0: word.Top,
                                            x1: word.Left + word.Width,
                                            y1: word.Top + word.Height
                                        }
                                    }))
                                ) || [];
                                const results = {
                                    ocrspace: {
                                        result: {
                                            product: matchedProduct.PRODUTO,
                                            volume: matchedProduct.ML,
                                            price: `R$ ${validatedPrice}`,
                                            id: matchedProduct.id,
                                            rawText: correctedText,
                                            confidence: Math.max(priceConfidence, productConfidence),
                                            emoji: productConfidence >= priceConfidence ? productEmoji : priceEmoji,
                                            label: productConfidence >= priceConfidence ? productLabel : priceLabel,
                                            words
                                        }
                                    }
                                };
                                updateState({
                                    ocrResults: results,
                                    newPrice: results.ocrspace.result.price.replace('R$ ', ''),
                                    confidenceData: { confidence: results.ocrspace.result.confidence, emoji: results.ocrspace.result.emoji, label: results.ocrspace.result.label },
                                    loading: false
                                });
                                if (results.ocrspace.result.price !== 'R$ 0,00') {
                                    updateState({ priceDetected: true });
                                    confetti({ 
                                        particleCount: 200, 
                                        spread: 80, 
                                        origin: { y: 0.6 },
                                        colors: ['#1E90FF', '#FFD700'],
                                        ticks: 300
                                    });
                                    setTimeout(() => updateState({ priceDetected: false }), 2000);
                                }
                            } catch (err) {
                                console.error('Erro no OCR.Space:', err.message, 'Resposta:', err.response?.data);
                                updateState({
                                    ocrResults: {
                                        ocrspace: {
                                            result: {
                                                error: `Erro no OCR.Space: ${err.message}. Verifique a resposta da API no console.`,
                                                rawText: '',
                                                product: bancoDeDados[0].PRODUTO,
                                                volume: bancoDeDados[0].ML,
                                                price: 'R$ 0,00',
                                                id: bancoDeDados[0].id,
                                                confidence: 0,
                                                emoji: '😞',
                                                label: 'Ruim',
                                                words: []
                                            }
                                        }
                                    },
                                    newPrice: '0,00',
                                    confidenceData: { confidence: 0, emoji: '😞', label: 'Ruim' },
                                    loading: false
                                });
                            }
                        });
                    };
                    reader.onerror = () => updateState({ error: 'Erro ao ler imagem', loading: false });
                } catch (err) {
                    updateState({ error: `Erro ao processar imagem: ${err.message}`, loading: false });
                }
            };

            const handlePriceChange = () => {
                if (!state.newPrice || !state.ocrResults.ocrspace) return;
                const isCervProduct = state.ocrResults.ocrspace.result.product.includes('CERV') || state.ocrResults.ocrspace.result.product.includes('CERVEJA');
                const { price: validatedPrice, confidence, emoji, label } = validatePrice(state.newPrice, isCervProduct, state.ocrResults.ocrspace.result.rawText);
                if (validatedPrice) {
                    updateState({
                        ocrResults: {
                            ocrspace: {
                                result: { ...state.ocrResults.ocrspace.result, price: `R$ ${validatedPrice}`, confidence, emoji, label }
                            }
                        },
                        confidenceData: { confidence, emoji, label },
                        priceDetected: true,
                        editPrice: false
                    });
                    confetti({ 
                        particleCount: 200, 
                        spread: 80, 
                        origin: { y: 0.6 },
                        colors: ['#1E90FF', '#FFD700'],
                        ticks: 300
                    });
                    setTimeout(() => updateState({ priceDetected: false }), 2000);
                }
            };

            const handleSubmit = async (result) => {
                if (!result?.id || !result?.price || result.price === 'R$ 0,00') return;
                updateState({ loading: true, error: null });
                try {
                    await retryOperation(() =>
                        axios.patch(
                            `https://api.baserow.io/api/database/rows/table/322640/${result.id}/?user_field_names=true`,
                            { "PREÇO": result.price.replace('R$ ', '').replace(',', '.') },
                            { headers: { Authorization: "Token UkqZsuMMnwE59fMqs8OwXX60SASP7FOd", "Content-Type": "application/json" }, timeout: 15000 }
                        )
                    );
                    updateState({ 
                        success: true,
                        successMessage: `PRODUTO ${result.product} FOI ENVIADO COM SUCESSO PARA BANCO DE DADOS NO VALOR DE ${result.price}`
                    });
                    confetti({ 
                        particleCount: 300, 
                        spread: 100, 
                        origin: { y: 0.5 }, 
                        colors: ['#22C55E', '#10B981', '#FFD700'],
                        ticks: 500
                    });
                    setTimeout(() => updateState({ success: false, successMessage: '' }), 5000);
                } catch (err) {
                    const errorMessage = err.response?.status === 401
                        ? 'Erro de autenticação: Token inválido ou expirado. Gere um novo token no Baserow e atualize o código.'
                        : `Erro ao enviar preço: ${err.response?.data?.detail || err.message}`;
                    updateState({ error: errorMessage, success: false });
                    console.error('Detalhes do erro:', err.response?.data || err.message);
                } finally {
                    updateState({ loading: false });
                }
            };

            return (
                <div className="container">
                    <header className="header">
                        {state.beerImageUrl && state.ocrResults.ocrspace?.result && !state.ocrResults.ocrspace.result.error ? (
                            <div className="flex flex-col items-center">
                                <div className="beer-image-container">
                                    <img src={state.beerImageUrl} alt="Produto Identificado" />
                                </div>
                                <hr className="separator" />
                                <p className="product-description">{state.ocrResults.ocrspace.result.product}</p>
                            </div>
                        ) : (
                            <div className="h-8"></div>
                        )}
                    </header>

                    <main className="flex flex-col gap-5">
                        {state.loading && (
                            <div className="flex flex-col items-center gap-3">
                                <div className="progress-bar w-full">
                                    <div className="progress-fill" style={{ width: `${state.progress}%` }}></div>
                                </div>
                                <p className="text-sm animate-pulse">Processando imagem...</p>
                            </div>
                        )}

                        {state.error && (
                            <div className="warning-modal">
                                <p>{state.error}</p>
                            </div>
                        )}

                        {state.imageUrl && !state.loading && (
                            <div className="image-container">
                                <img
                                    src={state.imageUrl}
                                    alt="Imagem para OCR"
                                    ref={imageRef}
                                    className={state.loading ? 'scanning-overlay' : ''}
                                />
                            </div>
                        )}

                        {state.ocrResults.ocrspace?.result && !state.ocrResults.ocrspace.result.error && (
                            <div className="flex flex-col gap-4">
                                <div className="flex flex-col gap-2">
                                    <p className="product-label font-medium text-lg">
                                        Produto: {state.ocrResults.ocrspace.result.product} ({formatVolume(state.ocrResults.ocrspace.result.volume)})
                                    </p>
                                    {state.editPrice ? (
                                        <div className="flex items-center gap-2">
                                            <input
                                                type="text"
                                                value={state.newPrice}
                                                onChange={(e) => updateState({ newPrice: e.target.value })}
                                                className="border rounded p-2 w-24 text-center bg-[var(--card-bg)] text-[var(--text-color)]"
                                                placeholder="0,00"
                                            />
                                            <button
                                                className="neon-button"
                                                onClick={handlePriceChange}
                                                disabled={state.loading || !state.newPrice}
                                            >
                                                Confirmar
                                            </button>
                                        </div>
                                    ) : (
                                        <p className="price-label font-medium text-lg">
                                            Preço: {state.ocrResults.ocrspace.result.price}
                                            <button
                                                className="ml-2 text-[var(--button-bg)] underline"
                                                onClick={() => updateState({ editPrice: true })}
                                            >
                                                Editar
                                            </button>
                                        </p>
                                    )}
                                    <ConfidenceBar
                                        confidence={state.confidenceData.confidence}
                                        emoji={state.confidenceData.emoji}
                                        label={state.confidenceData.label}
                                    />
                                </div>

                                {state.priceDetected && (
                                    <div className="warning-modal">
                                        <p>Preço detectado! Verifique antes de enviar.</p>
                                    </div>
                                )}

                                <button
                                    className="neon-button mt-2"
                                    onClick={() => handleSubmit(state.ocrResults.ocrspace.result)}
                                    disabled={state.loading || state.ocrResults.ocrspace.result.price === 'R$ 0,00'}
                                >
                                    Enviar Preço
                                </button>
                            </div>
                        )}

                        {state.success && (
                            <div className="success-overlay">
                                <svg className="checkmark" viewBox="0 0 52 52">
                                    <circle className="checkmark__circle" cx="26" cy="26" r="25" fill="none" />
                                    <path className="checkmark__check" fill="none" d="M14.1 27.2l7.1 7.2 16.7-16.8" />
                                </svg>
                                <h2>Sucesso!</h2>
                                <p>{state.successMessage}</p>
                            </div>
                        )}
                    </main>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
